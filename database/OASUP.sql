/******************************************************************************/
/***         Generated by IBExpert 2019.8.19.1 19.08.2019 20:21:20          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES UTF8;

CREATE DATABASE 'LOCALHOST:C:\FDB\oasup1.fdb'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 4096
DEFAULT CHARACTER SET UTF8 COLLATION UTF8;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_ACCESS_RIGHT_ID;
SET GENERATOR GEN_ACCESS_RIGHT_ID TO 5;

CREATE GENERATOR GEN_ACL_ID;
SET GENERATOR GEN_ACL_ID TO 240;

CREATE GENERATOR GEN_EA_FLDNUM;
SET GENERATOR GEN_EA_FLDNUM TO 1;

CREATE GENERATOR GEN_ETC;
SET GENERATOR GEN_ETC TO 116;

CREATE GENERATOR GEN_GROUPS_ID;
SET GENERATOR GEN_GROUPS_ID TO 3;

CREATE GENERATOR GEN_ID_ALL;
SET GENERATOR GEN_ID_ALL TO 10115;

CREATE GENERATOR GEN_MEMBERSHIP_ID;
SET GENERATOR GEN_MEMBERSHIP_ID TO 4;

CREATE GENERATOR IBE$TODO_ITEM_ID_GEN;
SET GENERATOR IBE$TODO_ITEM_ID_GEN TO 1;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION DELETE_ERROR 'Невозможно удалить';

CREATE EXCEPTION INSERT_ERROR 'Ошибка вставки записи';

CREATE EXCEPTION NEVER_PARAMS_VALUES 'Неверные значения параметров';

CREATE EXCEPTION PARAM_EXIST 'Параметр уже существует';

CREATE EXCEPTION VALUE_EXIST 'Значение уже существует';



/******************************************************************************/
/***                           Stored procedures                            ***/
/******************************************************************************/



SET TERM ^ ;

CREATE PROCEDURE CALCULATE_RES_REMAINDER (
    ID_LINK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_ALL_EA_BYOBJID (
    ID_LINK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_EA_ALTCAPTION (
    ID_EIDOS INTEGER,
    ID_HEADER INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_EA_MULTILNK_LINE (
    ID_EA INTEGER,
    LINE_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_EIDOS (
    ID_IN INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_HYPOTESIS (
    ID_IN INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_PRAGMA (
    ID_IN INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DEL_REGED_DLL (
    DLL_NAME4DELETE VARCHAR(255))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE EA_NUM_BY_NAME (
    FIELDNAME VARCHAR(64))
RETURNS (
    ID_EA INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_ALTCAPTIONS (
    ID_EIDOS INTEGER)
RETURNS (
    ID_HEADER INTEGER,
    NEWCAPTION VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_ATTRIBUTES_BYNUM (
    FIELDNUM INTEGER)
RETURNS (
    ID INTEGER,
    ID_CLASS INTEGER,
    FIELDNAME VARCHAR(64),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    LINKEDLEVELHP INTEGER,
    LINKEDOBJACT INTEGER,
    VISIBLE INTEGER,
    MULTILNK INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_DATE (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING TIMESTAMP,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_DLL (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_INT (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_LNKH (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_MULTITABLE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_LNKP (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_MULTILNKH (
    ID_EA_HEADER INTEGER,
    ID_OWNER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_MULTILNKP (
    ID_EA_HEADER INTEGER,
    ID_OWNER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_NUM (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING FLOAT,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_RB (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_SECUR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_LIST_STR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_NEWFIELDNAME
RETURNS (
    FLDNAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_RB (
    ID_EA INTEGER)
RETURNS (
    ID_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    ID_RB INTEGER,
    ID_VALUE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_DATE (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_DLL (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_INT (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_LNKH (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_LNKP (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_NUM (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_RB (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EA_TEMP_LIST_STR (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EIDOS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EIDOS_LIST (
    EIDOS_SPEC VARCHAR(64))
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_EIDOSEXTRAATTRIB_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    NAMESTOREDPROC VARCHAR(64),
    TEMPORALLISTSPNAME VARCHAR(64),
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_HYPOTESIS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_HYPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_HYPOTESIS_NAME_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_ID_TOPSPECIES (
    SPECIES VARCHAR(64))
RETURNS (
    ID_TOP_SPECIES INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_LINKED_HYPLIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_LINKED_PRAGMALIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_PRAGMA INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_MD5DLL (
    DLL_NAME VARCHAR(255))
RETURNS (
    MD5HASH VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_NUM_EIDOS_CHILDS (
    ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_PRAGMA (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_PRAGMA_LIST (
    ID_EIDOS INTEGER,
    ID_HYP_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_PRAGMA_NAME_LIST
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_PRAGMA_WITH_HIPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    HYP_NAME VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_RB (
    ID_VALUE INTEGER,
    ID_RB INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_REGED_DLLS
RETURNS (
    DLL_NAME VARCHAR(255),
    MD5_SUMM VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SET_EA_ALTCAPTION (
    ID_EIDOS INTEGER,
    ID_HEADER INTEGER,
    NEWCAPTION VARCHAR(255))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_DLL (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    KEYVALUE VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_LNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_MULTILNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_INLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SET_EA_RB (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    ID_RB INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_SIMPLE_DATE (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING TIMESTAMP,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_SIMPLE_INT (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_SIMPLE_NUM (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EA_SIMPLE_STR (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_EIDOS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SET_EIDOSEXTRAATTRIB (
    ID INTEGER,
    ID_EIDOS INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SET_HYPOTESIS (
    ID INTEGER,
    ID_EIDOS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SET_LEVEL_INEIDOS
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_MD5DLL (
    DLL_NAME VARCHAR(255),
    MD5HASH VARCHAR(255))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_PRAGMA (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_FOREIGN_KEY
RETURNS (
    PK VARCHAR(31),
    TABLENAME VARCHAR(31),
    FIELDNAMEPK VARCHAR(31),
    FK VARCHAR(31),
    TABLENAMESOURCE VARCHAR(31),
    FIELDNAMEFK VARCHAR(31))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_RB_FIELDS (
    RB_TABLENAME VARCHAR(31))
RETURNS (
    RDB$RELATION_NAME VARCHAR(31),
    RDB$FIELD_NAME VARCHAR(31),
    RDB$DESCRIPTION BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    RDB$FIELD_TYPE SMALLINT,
    RDB$TYPE_NAME VARCHAR(31),
    RDB$FIELD_LENGTH SMALLINT,
    RDB$FIELD_POSITION SMALLINT,
    RDB$FIELD_SCALE SMALLINT,
    RDB$FIELD_SUB_TYPE SMALLINT,
    RDB$FIELD_PRECISION SMALLINT,
    RDB$SEGMENT_LENGTH SMALLINT,
    RDB$NULL_FLAG SMALLINT,
    RDB$CONSTRAINT_NAME VARCHAR(31),
    RDB$CONSTRAINT_TYPE VARCHAR(11))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_RIGHTS_FOR_OBJECT (
    ID_OBJ INTEGER)
RETURNS (
    GROUP_NAME VARCHAR(255),
    RIGHT_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_TEMPORALY_VALUE (
    ID_HEADER INTEGER)
RETURNS (
    ID_LINK INTEGER,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_TYPE
RETURNS (
    ID SMALLINT,
    FIELD_TYPE SMALLINT,
    FIELD_TYPE_NAME VARCHAR(31),
    TYPE_NAME VARCHAR(62),
    FIELD_LENGTH SMALLINT,
    FIELD_SCALE SMALLINT,
    FIELD_SUB_TYPE SMALLINT,
    FIELD_PRECISION SMALLINT,
    SEGMENT_LENGTH SMALLINT,
    CAPTION VARCHAR(62))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_USER_OBJ (
    TYPE_OBJ SMALLINT)
RETURNS (
    ID INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_USER_OBJECTS
RETURNS (
    ID_OBJECT INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_USER_PRAGMA
RETURNS (
    MAX_OF_ACCESS_RIGHT INTEGER,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_GET_VAR_DT
RETURNS (
    DT TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_CURRENT_USER
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_ETC (
    OBJ VARCHAR(512),
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_ETC_ALL (
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_ETC_ALL2USER (
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_ETC_PARAMETERS (
    OBJECT_ID INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_ETC_PARAMETERS2USER (
    OBJECT VARCHAR(512),
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE SMALLINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_FLOATS (
    PARAM_LINKS INTEGER)
RETURNS (
    ID INTEGER,
    "VALUE" DOUBLE PRECISION,
    LINKS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_RB_DESCRIBER
RETURNS (
    ID INTEGER,
    RB_NAME VARCHAR(255),
    RB_TABLENAME VARCHAR(64),
    IS_RB_IERARCHY SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_READ_USER_INFO
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SET_ETC (
    ID INTEGER,
    OBJECT VARCHAR(512),
    ID_USER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SET_ETC2OBJ (
    UNAME VARCHAR(64),
    OLD_OBJECT VARCHAR(512),
    NEW_OBJECT VARCHAR(512))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SET_PARAMETERS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 4096)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SET_RENAME_PARAMETER (
    ID INTEGER,
    NEW_NAME VARCHAR(250))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_SET_RIGHT (
    GID INTEGER,
    OID INTEGER,
    RID INTEGER,
    MODE SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_SET_VAR_DT (
    DT TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE VA_EIDOS
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64),
    LVL SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE VA_HYPOTESIS
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE VA_PRAGMA
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
AS
BEGIN
  SUSPEND;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ACCESS_RIGHT (
    ID    INTEGER NOT NULL,
    AO    SMALLINT DEFAULT 0 NOT NULL,
    A     SMALLINT DEFAULT 0 NOT NULL,
    W     SMALLINT DEFAULT 0 NOT NULL,
    D     SMALLINT DEFAULT 0 NOT NULL,
    R     SMALLINT DEFAULT 0 NOT NULL,
    NAME  VARCHAR(64)
);

CREATE TABLE ACL (
    ID            INTEGER NOT NULL,
    GID           INTEGER NOT NULL,
    ACCESS_RIGHT  INTEGER NOT NULL,
    ID_OBJECT     INTEGER NOT NULL
);

CREATE TABLE DLL_MD5 (
    DLL_NAME  VARCHAR(255) NOT NULL,
    MD5SUM    VARCHAR(255)
);

CREATE TABLE EIDOS (
    ID           INTEGER NOT NULL,
    ID_PARENT    INTEGER,
    NAME         VARCHAR(255) NOT NULL,
    SPECIES      VARCHAR(64),
    "LEVEL"      SMALLINT DEFAULT 1 NOT NULL,
    DATE_DELETE  TIMESTAMP
);

CREATE TABLE ETC (
    ID       INTEGER NOT NULL,
    OBJECT   VARCHAR(512) NOT NULL,
    ID_USER  INTEGER NOT NULL
);

CREATE TABLE ETC_PARAMETERS (
    ID            INTEGER NOT NULL,
    NAME          VARCHAR(250) NOT NULL,
    PARAM_TYPE    SMALLINT NOT NULL,
    ID_OBJECT     INTEGER NOT NULL,
    DATE_VALUE    TIMESTAMP,
    FLOAT_VALUE   DOUBLE PRECISION,
    INT_VALUE     BIGINT,
    STRING_VALUE  VARCHAR(255),
    BLOB_VALUE    BLOB SUB_TYPE 0 SEGMENT SIZE 4096
);

CREATE TABLE EXTRAATRIB_RB (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    INTEGER NOT NULL,
    ID_RB      INTEGER NOT NULL
);

CREATE TABLE EXTRAATTRIB_ALTCAPTION (
    ID_EIDOS    INTEGER,
    NEWCAPTION  VARCHAR(255),
    ID_HEADER   INTEGER
);

CREATE TABLE EXTRAATTRIB_DLL (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    VARCHAR(255),
    KEYVALUE   VARCHAR(255)
);

CREATE TABLE EXTRAATTRIB_HEADER (
    ID               INTEGER NOT NULL,
    ID_CLASS         INTEGER NOT NULL,
    FIELDNAME        VARCHAR(64),
    FIELDTYPE        INTEGER,
    CAPTION          VARCHAR(255) NOT NULL,
    ID_BELONGFOR     INTEGER,
    ID_RB_DESCRIBER  INTEGER,
    DLL_FILENAME     VARCHAR(64),
    DLL_PROCNAME     VARCHAR(64),
    TEMPORALITY      INTEGER,
    REQUIRED         INTEGER,
    LINKEDLEVELHP    INTEGER,
    LINKEDOBJACT     INTEGER,
    VISIBLE          INTEGER,
    LOCKED           INTEGER,
    MULTILNK         INTEGER,
    LNK_SPECIES      VARCHAR(64),
    LNK_EIDOSID      INTEGER,
    LNK_HYPID        INTEGER,
    LNK_NEEDLIST     INTEGER
);

CREATE TABLE EXTRAATTRIB_LNK (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    KEYVALUE   INTEGER,
    RATIO      FLOAT
);

CREATE TABLE EXTRAATTRIB_SIM_DATE (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    TIMESTAMP
);

CREATE TABLE EXTRAATTRIB_SIM_INT (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    INTEGER
);

CREATE TABLE EXTRAATTRIB_SIM_NUM (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    FLOAT
);

CREATE TABLE EXTRAATTRIB_SIM_STR (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    VARCHAR(255)
);

CREATE TABLE EXTRAATTRIB_SUPPORT (
    FIELDTYPE           INTEGER,
    NAMESTOREDPROC      VARCHAR(64),
    TEMPORALLISTSPNAME  VARCHAR(64),
    DESCRIBER           VARCHAR(255)
);

CREATE TABLE FIELDS_TYPE (
    ID               SMALLINT,
    FIELD_TYPE       SMALLINT NOT NULL,
    FIELD_TYPE_NAME  VARCHAR(31) NOT NULL,
    TYPE_NAME        VARCHAR(62),
    FIELD_LENGTH     SMALLINT,
    FIELD_SCALE      SMALLINT,
    FIELD_SUB_TYPE   SMALLINT,
    FIELD_PRECISION  SMALLINT,
    SEGMENT_LENGTH   SMALLINT,
    CAPTION          VARCHAR(62)
);

CREATE TABLE GROUPS (
    ID    INTEGER NOT NULL,
    NAME  VARCHAR(255) NOT NULL
);

CREATE TABLE HYPOTESIS (
    ID           INTEGER NOT NULL,
    ID_EIDOS     INTEGER NOT NULL,
    DATE_DELETE  TIMESTAMP
);

CREATE TABLE IBE$TODO (
    ITEM_ID             INTEGER NOT NULL,
    OBJECT_NAME         VARCHAR(64) CHARACTER SET UNICODE_FSS,
    OBJECT_TYPE         INTEGER,
    ITEM_PRIORITY       SMALLINT DEFAULT 0 NOT NULL,
    ITEM_STATE          SMALLINT DEFAULT 0 NOT NULL,
    ITEM_CAPTION        VARCHAR(255) NOT NULL,
    ITEM_DESCRIPTION    BLOB SUB_TYPE 1 SEGMENT SIZE 80,
    RESPONSIBLE_PERSON  VARCHAR(64),
    ITEM_TIMESTAMP      TIMESTAMP NOT NULL,
    ITEM_DEADLINE       DATE,
    ITEM_CATEGORY       VARCHAR(64),
    ITEM_OWNER          VARCHAR(64) CHARACTER SET UNICODE_FSS NOT NULL
);

CREATE TABLE ID_OBJ (
    ID         INTEGER,
    TYPE_OBJ   SMALLINT DEFAULT 0,
    ID_PARENT  INTEGER
);

CREATE TABLE IRB_HUMANS (
    ID                INTEGER NOT NULL,
    FIRSTNAME         VARCHAR(255),
    MIDDLENAME        VARCHAR(255),
    LASTNAME          VARCHAR(255),
    LNK_ORGANIZATION  INTEGER,
    JOB_NAME          VARCHAR(255)
);

CREATE TABLE IRB_OPERATIONS (
    ID    INTEGER NOT NULL,
    NAME  VARCHAR(255) NOT NULL
);

CREATE TABLE IRB_PLACESUSE (
    ID         INTEGER NOT NULL,
    ID_PARENT  INTEGER NOT NULL,
    NAME       VARCHAR(255) NOT NULL
);

CREATE TABLE IRB_RESOURCES (
    ID             INTEGER NOT NULL,
    ID_PARENT      INTEGER NOT NULL,
    NAME           VARCHAR(255) NOT NULL,
    LNK_UNITMESUR  INTEGER NOT NULL
);

CREATE TABLE IRB_STRUCTURES (
    ID                INTEGER NOT NULL,
    ID_PARENT         INTEGER NOT NULL,
    NAME              VARCHAR(255) NOT NULL,
    INN               VARCHAR(30),
    LNK_HUMANS_CHIEF  INTEGER
);

CREATE TABLE IRB_UNITMESUREMENT (
    ID         INTEGER NOT NULL,
    ID_PARENT  INTEGER NOT NULL,
    NAME       VARCHAR(255) NOT NULL
);

CREATE TABLE MEMBERSHIP (
    ID         INTEGER NOT NULL,
    GID        INTEGER NOT NULL,
    USER_NAME  VARCHAR(64) NOT NULL
);

CREATE TABLE MULTIPLEXLNK (
    ID         INTEGER NOT NULL,
    ID_LINK    INTEGER,
    ID_HEADER  INTEGER NOT NULL
);

CREATE TABLE PRAGMA (
    ID            INTEGER NOT NULL,
    ID_EIDOS      INTEGER,
    ID_HYPOTESIS  INTEGER,
    DATE_DELETE   TIMESTAMP
);

CREATE TABLE RB_DESCRIBER (
    ID              INTEGER NOT NULL,
    RB_NAME         VARCHAR(255) NOT NULL,
    RB_TABLENAME    VARCHAR(64) NOT NULL,
    IS_RB_IERARCHY  SMALLINT DEFAULT 0 NOT NULL,
    SQLSTRING       VARCHAR(255)
);

CREATE TABLE TEMPORALITY (
    ID         INTEGER NOT NULL,
    ID_LINK    INTEGER,
    DATE_TIME  TIMESTAMP,
    ID_HEADER  INTEGER NOT NULL
);

CREATE TABLE USERS (
    UID                  INTEGER NOT NULL,
    NAME                 VARCHAR(64) NOT NULL,
    ID_TYPE_ACCES_RIGHT  INTEGER NOT NULL,
    FULL_NAME            VARCHAR(255),
    DESCRIPTIONS         VARCHAR(255),
    IS_DELETED           SMALLINT DEFAULT 0,
    IS_DISABLED          SMALLINT DEFAULT 0
);

CREATE TABLE VAR_DT (
    USER_NAME  VARCHAR(64) DEFAULT user,
    DT         TIMESTAMP DEFAULT 'NOW'
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: VW_CONSTRAINTS */
CREATE VIEW VW_CONSTRAINTS(
    RDB$INDEX_NAME,
    RDB$RELATION_NAME,
    RDB$UNIQUE_FLAG,
    RDB$INDEX_INACTIVE,
    RDB$INDEX_TYPE,
    RDB$FIELD_NAME,
    RDB$FIELD_POSITION,
    RDB$CONSTRAINT_TYPE,
    RDB$CONSTRAINT_NAME)
AS
select i.rdb$index_name,
i.rdb$relation_name,
i.rdb$unique_flag,
i.rdb$index_inactive,
i.rdb$index_type,
isg.rdb$field_name,
isg.rdb$field_position,
c.RDB$CONSTRAINT_TYPE,
c.RDB$CONSTRAINT_NAME
from rdb$indices i
LEFT JOIN rdb$index_segments isg ON (isg.rdb$index_name = i.rdb$index_name)
LEFT JOIN rdb$relation_constraints c ON (i.rdb$index_name = c.rdb$index_name)
WHERE (not (c.RDB$CONSTRAINT_TYPE is NULL))
;



/* View: VW_FIELDS */
CREATE VIEW VW_FIELDS(
    RDB$RELATION_NAME,
    RDB$FORMAT,
    RDB$SYSTEM_FLAG,
    RDB$RELATION_ID,
    RDB$FIELD_NAME,
    RDB$DESCRIPTION,
    RDB$TYPE_NAME,
    RDB$FIELD_LENGTH,
    RDB$FIELD_POSITION,
    RDB$FIELD_TYPE,
    RDB$FIELD_SCALE,
    RDB$FIELD_SUB_TYPE,
    RDB$FIELD_PRECISION,
    RDB$SEGMENT_LENGTH,
    RDB$NULL_FLAG)
AS
SELECT RDB$RELATIONS.RDB$RELATION_NAME, RDB$RELATIONS.RDB$FORMAT, RDB$RELATIONS.RDB$SYSTEM_FLAG, RDB$RELATIONS.RDB$RELATION_ID, RDB$RELATION_FIELDS.RDB$FIELD_NAME, RDB$RELATION_FIELDS.RDB$DESCRIPTION, RDB$TYPES.RDB$TYPE_NAME, RDB$FIELDS.RDB$FIELD_LENGTH, RDB$RELATION_FIELDS.RDB$FIELD_POSITION, RDB$FIELDS.RDB$FIELD_TYPE, RDB$FIELDS.RDB$FIELD_SCALE, RDB$FIELDS.RDB$FIELD_SUB_TYPE, RDB$FIELDS.RDB$FIELD_PRECISION, RDB$FIELDS.RDB$SEGMENT_LENGTH, RDB$RELATION_FIELDS.RDB$NULL_FLAG
FROM RDB$RELATION_FIELDS
   INNER JOIN RDB$FIELDS ON (RDB$RELATION_FIELDS.RDB$FIELD_SOURCE = RDB$FIELDS.RDB$FIELD_NAME)
   INNER JOIN RDB$TYPES ON (RDB$FIELDS.RDB$FIELD_TYPE = RDB$TYPES.RDB$TYPE)
   INNER JOIN RDB$RELATIONS ON (RDB$RELATION_FIELDS.RDB$RELATION_NAME = RDB$RELATIONS.RDB$RELATION_NAME)
WHERE 
   (
      (RDB$TYPES.RDB$FIELD_NAME = 'RDB$FIELD_TYPE')
   and 
      (RDB$RELATIONS.RDB$SYSTEM_FLAG = 0)
   )
;



/* View: VW_USER_OBIECTS */
CREATE VIEW VW_USER_OBIECTS(
    ID_OBJECT,
    MAX_OF_ACCESS_RIGHT)
AS
SELECT ACL.ID_OBJECT, MAX( ACL.ACCESS_RIGHT ) MAX_OF_ACCESS_RIGHT
FROM MEMBERSHIP
   --INNER JOIN GROUPS ON (MEMBERSHIP.GID = GROUPS.ID)
   INNER JOIN ACL ON (MEMBERSHIP.GID = ACL.GID)
WHERE 
   (
      (MEMBERSHIP.USER_NAME = USER)
   )
GROUP BY ACL.ID_OBJECT
;


INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (5, 1, 1, 1, 1, 1, 'Администрирование');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (1, 0, 0, 0, 0, 1, 'Только чтение');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (2, 0, 0, 1, 0, 1, 'Изменение');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (3, 0, 1, 1, 0, 1, 'Изменение и добавление');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (4, 0, 1, 1, 1, 1, 'Полный доступ');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (0, 0, 0, 0, 0, 0, 'Нет доступа');

COMMIT WORK;

INSERT INTO GROUPS (ID, NAME) VALUES (1, 'Администраторы');
INSERT INTO GROUPS (ID, NAME) VALUES (2, 'Пользователи');
INSERT INTO GROUPS (ID, NAME) VALUES (3, 'Бухгалтеры');

COMMIT WORK;

INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (1, 1, 1, 1);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (2, 1, 4, 2);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (3, 1, 4, 3);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (4, 1, 4, 4);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (5, 1, 4, 5);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (6, 1, 4, 20);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (7, 1, 4, 21);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (8, 1, 4, 22);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (9, 1, 4, 23);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (10, 1, 4, 24);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (11, 1, 4, 25);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (12, 1, 4, 27);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (13, 1, 4, 28);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (14, 1, 4, 30);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (15, 1, 4, 31);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (16, 1, 4, 32);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (17, 1, 4, 50);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (18, 1, 4, 60);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (19, 1, 4, 61);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (20, 1, 4, 62);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (21, 1, 4, 63);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (22, 1, 4, 70);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (23, 1, 4, 71);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (24, 1, 4, 72);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (25, 1, 4, 80);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (26, 1, 4, 81);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (27, 1, 4, 82);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (28, 1, 4, 90);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (29, 1, 4, 91);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (30, 1, 4, 92);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (31, 1, 4, 93);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (32, 1, 4, 94);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (33, 1, 4, 95);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (201, 1, 4, 10002);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (202, 1, 4, 10003);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (203, 1, 4, 10006);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (204, 1, 4, 10008);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (205, 1, 4, 10011);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (206, 1, 4, 10014);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (207, 1, 4, 10016);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (208, 1, 4, 10038);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (209, 1, 4, 10039);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (210, 1, 4, 10046);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (211, 1, 4, 10050);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (212, 1, 4, 10062);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (213, 1, 4, 10063);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (214, 1, 4, 10064);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (215, 1, 4, 10065);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (216, 1, 4, 10066);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (217, 1, 4, 10070);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (218, 1, 4, 10074);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (219, 1, 4, 10075);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (220, 1, 4, 10080);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (221, 1, 4, 10081);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (222, 1, 4, 10082);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (223, 1, 4, 10083);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (224, 1, 4, 10084);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (225, 1, 4, 10085);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (226, 1, 4, 10088);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (227, 1, 4, 10092);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (228, 1, 4, 10096);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (229, 1, 4, 10097);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (231, 1, 4, 10099);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (232, 1, 4, 10100);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (233, 1, 4, 10101);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (234, 1, 4, 10102);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (235, 1, 4, 10105);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (236, 1, 4, 10108);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (237, 1, 4, 10112);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (238, 1, 4, 10113);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (239, 1, 4, 10114);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (240, 1, 4, 10115);

COMMIT WORK;

INSERT INTO DLL_MD5 (DLL_NAME, MD5SUM) VALUES ('libapparmor.so.1.0.2', '25519b255159b357c3382798866e3274');

COMMIT WORK;

INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (1, 0, 'root', 'ALL', 1, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (2, 1, 'Объекты учета', 'OBJ', 2, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (3, 1, 'Подучетные действия', 'ACT', 2, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (4, 1, 'Ресурсы', 'RES', 2, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (5, 1, 'Нормативно-справочная информация', 'NSI', 2, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (20, 2, 'Оборудование', 'OBJ', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (21, 20, 'Вычислительная техника', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (22, 20, 'Сетевое', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (23, 21, 'ПК (системные блоки)', 'OBJ', 5, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (24, 21, 'Серверы', 'OBJ', 5, '2011-09-12 17:57:05');
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (25, 20, 'Мониторы', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (27, 20, 'Принтеры', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (28, 20, 'Сканеры', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (30, 20, 'Консоли управления', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (31, 22, 'Маршрутизаторы', 'OBJ', 5, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (32, 22, 'Коммутаторы', 'OBJ', 5, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (50, 2, 'Учетные записи пользователей', 'OBJ', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (60, 2, 'Программное обеспечение', 'OBJ', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (61, 60, 'Операционные системы', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (62, 60, 'Среднего уровня (портал, информационный сайт...)', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (63, 60, 'Прикладное', 'OBJ', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (70, 3, 'Эксплуатация', 'ACT', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (71, 3, 'Осмотры', 'ACT', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (72, 3, 'Ремонты', 'ACT', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (80, 4, 'Запасные части', 'RES', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (81, 4, 'Расходные материалы', 'RES', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (82, 81, 'Картриджи', 'RES', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (90, 5, 'Единицы измерения', 'NSI', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (91, 5, 'Список работников', 'NSI', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (92, 5, 'Здания и корпуса', 'NSI', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (93, 5, 'Компьютерная техника', 'NSI', 3, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (94, 93, 'Тип процессора', 'NSI', 4, NULL);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL", DATE_DELETE) VALUES (95, 93, 'Тип памяти', 'NSI', 4, NULL);

COMMIT WORK;

INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (2, 'WidgetAppearance\QEidosTreeWidget\splitter_e', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (3, 'FormsAppearance\MainWindow', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (15, 'FormsAppearance\HypotesisEditForm\EidosID=24:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (18, 'FormsAppearance\PragmaEditForm\EidosID=24:pragma', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (21, 'WidgetAppearance\QEidosTreeWidget\splitter_2', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (22, 'WidgetAppearance\QEidosTreeWidget\splitter', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (23, 'FormsAppearance\LinksExplorer', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (26, 'FormsAppearance\DialogEditHronologyEA', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (35, 'FormsAppearance\HypotesisEditForm\EidosID=23:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (38, 'FormsAppearance\PragmaEditForm\EidosID=23:pragma', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (41, 'FormsAppearance\Multilinks', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (44, 'WidgetAppearance\QEidosTreeWidget\Dialog_Eidos', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (45, 'FormsAppearance\Dialog_Eidos', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (49, 'FormsAppearance\ChoicePragma_Dialog', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (55, 'FormsAppearance\HypotesisEditForm\EidosID=91:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (58, 'FormsAppearance\HypotesisEditForm\EidosID=94:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (61, 'FormsAppearance\HypotesisEditForm\EidosID=95:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (64, 'FormsAppearance\HypotesisEditForm\EidosID=92:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (68, 'FormsAppearance\Dialog', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (71, 'FormsAppearance\es_mainwindowClass', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (78, 'WidgetAppearance\QEidosTreeWidget\splitter_V', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (82, 'FormsAppearance\mw_DLL_handler', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (85, 'ProgramConfig', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (87, 'FormsAppearance\HypotesisEditForm\EidosID=31:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (90, 'FormsAppearance\PragmaEditForm\EidosID=31:pragma', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (93, 'FormsAppearance\HypotesisEditForm\EidosID=71:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (96, 'FormsAppearance\PragmaEditForm\EidosID=71:pragma', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (99, 'FormsAppearance\HypotesisEditForm\EidosID=70:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (102, 'FormsAppearance\HypotesisEditForm\EidosID=27:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (105, 'FormsAppearance\PragmaEditForm\EidosID=27:pragma', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (108, 'FormsAppearance\HypotesisEditForm\EidosID=82:hypotesis', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (111, 'FormsAppearance\PragmaEditForm\EidosID=70:pragma', 9);
INSERT INTO ETC (ID, OBJECT, ID_USER) VALUES (114, 'FormsAppearance\PragmaEditForm\EidosID=82:pragma', 9);

COMMIT WORK;

INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (4, 'Column_Name_width', 6, 2, NULL, NULL, 439, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (5, 'Column_ID_width', 6, 2, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (6, 'Column_ID_PARENT_width', 6, 2, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (7, 'width', 6, 3, NULL, NULL, 1149, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (8, 'height', 6, 3, NULL, NULL, 828, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (9, 'splitter_e\0', 6, 3, NULL, NULL, 445, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (10, 'splitter_e\1', 6, 3, NULL, NULL, 677, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (11, 'splitter_hp\0', 6, 3, NULL, NULL, 336, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (12, 'splitter_hp\1', 6, 3, NULL, NULL, 344, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (13, 'comboBox_Species', 6, 3, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (14, 'EidosID', 6, 3, NULL, NULL, 82, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (16, 'width', 6, 15, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (17, 'height', 6, 15, NULL, NULL, 267, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (19, 'width', 6, 18, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (20, 'height', 6, 18, NULL, NULL, 631, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (24, 'width', 6, 23, NULL, NULL, 962, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (25, 'height', 6, 23, NULL, NULL, 584, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (42, 'width', 6, 41, NULL, NULL, 580, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (43, 'height', 6, 41, NULL, NULL, 550, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (27, 'width', 6, 26, NULL, NULL, 469, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (28, 'height', 6, 26, NULL, NULL, 506, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (46, 'width', 6, 45, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (47, 'height', 6, 45, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (36, 'width', 6, 35, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (37, 'height', 6, 35, NULL, NULL, 240, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (39, 'width', 6, 38, NULL, NULL, 796, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (40, 'height', 6, 38, NULL, NULL, 583, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (56, 'width', 6, 55, NULL, NULL, 774, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (57, 'height', 6, 55, NULL, NULL, 153, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (48, 'checkBoxState', 2, 45, NULL, NULL, 1, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (50, 'width', 6, 49, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (51, 'height', 6, 49, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (29, 'Column_Name_width', 6, 21, NULL, NULL, 94, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (30, 'Column_ID_width', 6, 21, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (31, 'Column_ID_PARENT_width', 6, 21, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (32, 'Column_Name_width', 6, 22, NULL, NULL, 462, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (33, 'Column_ID_width', 6, 22, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (34, 'Column_ID_PARENT_width', 6, 22, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (67, 'action_View_IDs', 2, 3, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (69, 'width', 6, 68, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (70, 'height', 6, 68, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (59, 'width', 6, 58, NULL, NULL, 750, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (60, 'height', 6, 58, NULL, NULL, 153, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (62, 'width', 6, 61, NULL, NULL, 702, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (63, 'height', 6, 61, NULL, NULL, 153, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (52, 'Column_Name_width', 6, 44, NULL, NULL, 772, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (53, 'Column_ID_width', 6, 44, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (54, 'Column_ID_PARENT_width', 6, 44, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (65, 'width', 6, 64, NULL, NULL, 764, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (66, 'height', 6, 64, NULL, NULL, 155, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (72, 'width', 6, 71, NULL, NULL, 1254, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (73, 'height', 6, 71, NULL, NULL, 804, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (74, 'splitter_V\0', 6, 71, NULL, NULL, 468, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (75, 'splitter_V\1', 6, 71, NULL, NULL, 775, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (76, 'splitter_H\0', 6, 71, NULL, NULL, 195, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (77, 'splitter_H\1', 6, 71, NULL, NULL, 527, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (79, 'Column_Name_width', 6, 78, NULL, NULL, 462, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (80, 'Column_ID_width', 6, 78, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (81, 'Column_ID_PARENT_width', 6, 78, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (83, 'width', 6, 82, NULL, NULL, 1036, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (84, 'height', 6, 82, NULL, NULL, 261, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (86, 'UseETCType', 6, 85, NULL, NULL, 0, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (88, 'width', 6, 87, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (89, 'height', 6, 87, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (91, 'width', 6, 90, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (92, 'height', 6, 90, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (94, 'width', 6, 93, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (95, 'height', 6, 93, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (97, 'width', 6, 96, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (98, 'height', 6, 96, NULL, NULL, 215, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (100, 'width', 6, 99, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (101, 'height', 6, 99, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (103, 'width', 6, 102, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (104, 'height', 6, 102, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (106, 'width', 6, 105, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (107, 'height', 6, 105, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (109, 'width', 6, 108, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (110, 'height', 6, 108, NULL, NULL, 700, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (112, 'width', 6, 111, NULL, NULL, 719, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (113, 'height', 6, 111, NULL, NULL, 306, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (115, 'width', 6, 114, NULL, NULL, 800, NULL);
INSERT INTO ETC_PARAMETERS (ID, NAME, PARAM_TYPE, ID_OBJECT, DATE_VALUE, FLOAT_VALUE, INT_VALUE, STRING_VALUE) VALUES (116, 'height', 6, 114, NULL, NULL, 700, NULL);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1000, 1, 'HypName', 1, 'Наименование', 1, NULL, NULL, NULL, 0, 1, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1001, 1, 'PragmaDate', 11, 'Дата создания(получения)', 2, NULL, NULL, NULL, 0, 1, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1002, 1, 'Security', 105, 'Право доступа к объекту для пользователя в контексте роли', 1, NULL, NULL, NULL, 0, 0, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1003, 3, 'LnkOBJ', 104, 'Ссылка на экземпляр объекта учета над которым проводилось действие', 2, NULL, NULL, NULL, 0, 1, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1004, 4, 'LNK_ForkedRES', 104, 'Ссылка на экземпляр ресурса, от которого был отщеплен данный экземпляр', 2, NULL, NULL, NULL, 0, 0, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1005, 4, 'Remainder', 6, 'Остаток', 2, NULL, NULL, NULL, 0, 0, 0, 0, 1, 1, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1006, 4, 'LNK_ACTBelongFor', 104, 'Ссылка на действие на которое списан ресурс', 2, NULL, NULL, NULL, 0, 0, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1007, 4, 'Quantity', 6, 'Количество', 2, NULL, NULL, NULL, 0, 1, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2001, 20, 'link2building', 103, 'Размещение', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 92, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2002, 20, 'Dateinituse', 11, 'Дата ввода в эксплуатацию', 2, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2003, 20, 'CheckNumber', 1, 'Приобретено по счету', 2, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2004, 20, 'AccMonth4use', 3, 'Срок полезного использования(мес)', 1, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2005, 20, 'GuarantyMonths', 3, 'Гарантийный срок(мес)', 2, NULL, NULL, NULL, 0, 1, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2006, 20, 'serialNumber', 1, 'Серийный номер', 2, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2007, 20, 'Internalcodever', 1, 'Версия прошивки', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2008, 20, 'link2worker', 103, 'Ответственное лицо', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 91, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2009, 20, 'Developer', 1, 'Производитель', 1, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2010, 20, 'Developercontakts', 1, 'Контакная информация производителя', 1, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2011, 21, 'IPAdress', 1, 'IP адрес', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2012, 21, 'CPUType', 103, 'Тип CPU', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 94, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2013, 21, 'HDDVolume', 3, 'Емкость диска(ов) ГБ', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2014, 21, 'RAMType', 103, 'Тип RAM', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 95, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2015, 21, 'RAMVolume', 3, 'Объем оперативной памяти МБ', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2016, 21, 'DVDOnboard', 5, 'Установлен привод DVD', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2020, 24, 'RAIDLevel', 3, 'Уровень RAID', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (10001, 20, 'Multilink', 104, 'Multilink1', 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 1, NULL, NULL, NULL, NULL);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (10004, 20, 'ML2', 104, 'Подчиненный компьютер', 2, NULL, NULL, NULL, 0, 0, NULL, NULL, 0, 0, 1, NULL, NULL, NULL, NULL);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (10005, 20, 'ML3', 103, 'Ссылка на тип', 2, NULL, NULL, NULL, 0, 0, NULL, NULL, 0, 0, 1, NULL, NULL, NULL, NULL);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (10005, 10018, 10006, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (10005, 10019, 10016, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10040, 10039, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2014, 10068, 10065, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10041, 10039, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2012, 10069, 10064, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10042, 10038, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10047, 10046, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10056, 10050, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10071, 10070, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (10005, 10073, 10002, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (10004, 10035, 10011, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10076, 10074, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10077, 10074, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10078, 10074, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10079, 10074, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10089, 10050, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10091, 10074, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10093, 10050, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10095, 10070, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (1003, 10099, 10092, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (1003, 10100, 10088, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2008, 10109, 10039, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (2001, 10111, 10070, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (1003, 10113, 10108, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (1006, 10115, 10113, 1);
INSERT INTO EXTRAATTRIB_LNK (ID_HEADER, ID_LINK, KEYVALUE, RATIO) VALUES (1004, 10115, 10114, 1);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10003, '2009-05-21 20:01:33');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10008, '2009-05-28 19:54:22');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10011, '2009-05-28 19:56:01');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10014, '2009-05-28 19:56:12');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (2002, 10003, '2010-01-12 00:01:00');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (2002, 10008, '2010-02-01 00:00:00');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10088, '2013-11-04 20:23:15');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (2002, 10088, '2013-03-02 00:00:00');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10092, '2013-11-04 20:24:23');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10096, '2013-11-04 20:25:43');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (2002, 10092, '2013-03-02 00:00:00');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10099, '2013-05-04 20:29:30');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10100, '2013-06-04 20:30:15');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10108, '2013-01-04 20:35:42');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (2002, 10108, '2013-01-14 20:35:00');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10113, '2013-11-04 20:37:36');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10114, '2013-07-04 20:38:22');
INSERT INTO EXTRAATTRIB_SIM_DATE (ID_HEADER, ID_LINK, "VALUE") VALUES (1001, 10115, '2013-11-04 20:38:52');

COMMIT WORK;

INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2004, 10006, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2016, 10010, 1);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2016, 10013, 1);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2004, 10016, 24);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2004, 10002, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2005, 10003, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2016, 10052, 1);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2015, 10053, 16000);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2020, 10055, 10);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2015, 10059, 1024);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2013, 10060, 500);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2016, 10067, 0);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2005, 10008, 24);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2004, 10085, 60);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2005, 10088, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2005, 10092, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2004, 10102, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2004, 10105, 36);
INSERT INTO EXTRAATTRIB_SIM_INT (ID_HEADER, ID_LINK, "VALUE") VALUES (2005, 10108, 12);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_SIM_NUM (ID_HEADER, ID_LINK, "VALUE") VALUES (1007, 10114, 10);
INSERT INTO EXTRAATTRIB_SIM_NUM (ID_HEADER, ID_LINK, "VALUE") VALUES (1005, 10114, 9);
INSERT INTO EXTRAATTRIB_SIM_NUM (ID_HEADER, ID_LINK, "VALUE") VALUES (1007, 10115, 1);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10002, 'IBM Power 5');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10006, 'DELL IMPRESSO');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2009, 10007, 'DELL');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10009, '1');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10008, '123');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2003, 10008, '5020 от 18.10.2009');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10012, '2');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10011, '2');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10015, '2');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10014, '3');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10016, 'HP ');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2009, 10017, 'Hewlett Packard');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10038, 'Головырин Владислав Владимирович');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10039, 'Коробкин Юрий Михайлович');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10043, 'Desktop ваариант персонального компьютера');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10044, 'DELL Russia');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10045, 'HP ru');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10046, 'Дудандров Андрей Владимирович');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2011, 10061, '192.168.1.3');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10048, 'IBM.RU');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2009, 10049, 'IBM ');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10050, 'Дворянинов Максим Викторович');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10051, '1.2');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10003, '165327990-22');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2011, 10054, '172.12.13.24');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10062, 'Power 5');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10063, 'Intel Celeron 1200');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10064, 'Intel Core 2 Duo 6550');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10065, 'DDR2 6400');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10066, 'DDR2 5300');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10070, 'Корпус 3.14 Проектный офис');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10072, '1.3');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10074, 'ОАСУП');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10075, 'Заводоуправление');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10080, 'DDR3 800');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10081, 'Intel i7');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10082, 'Intel i5');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10083, 'Intel i3');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10084, 'DDR 1300');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10085, 'CISCO 6500');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10086, 'CISCO SYSTEMS, USA');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2009, 10087, 'CISCO SYSTEMS');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10090, '1.12');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10088, '778009755467');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2003, 10088, '12523');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10094, '1.12');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10092, '778009755468');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2003, 10092, '12523');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10097, 'Плановый осмотр');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10101, 'Выдача картриджей');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10102, 'HP DJ2800');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10103, 'Хьюлетт-Паккард (HP), Торговая Компания, ЗАО, Адрес: Артиллерийская ул., 1, оф. 301, Санкт-Петербург, 191014
Телефон:8 (812) 346-74-74');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2009, 10104, 'HP');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10105, 'HP LaserJet 4200');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2009, 10106, 'HP');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2010, 10107, 'Хьюлетт-Паккард (HP), Торговая Компания, ЗАО, Адрес: Артиллерийская ул., 1, оф. 301, Санкт-Петербург, 191014
Телефон:8 (812) 346-74-74');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2007, 10110, '1');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2006, 10108, '2345542213');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (2003, 10108, '12');
INSERT INTO EXTRAATTRIB_SIM_STR (ID_HEADER, ID_LINK, "VALUE") VALUES (1000, 10112, 'HP LJ4200 A10');

COMMIT WORK;

INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (1, 'GET_EA_LIST_STR', 'GET_EA_TEMP_LIST_STR', 'ft_String');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (5, 'GET_EA_LIST_INT', 'GET_EA_TEMP_LIST_INT', 'ft_Boolean');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (3, 'GET_EA_LIST_INT', 'GET_EA_TEMP_LIST_INT', 'ft_Integer');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (6, 'GET_EA_LIST_NUM', 'GET_EA_TEMP_LIST_NUM', 'ft_Float');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (11, 'GET_EA_LIST_DATE', 'GET_EA_TEMP_LIST_DATE', 'ft_DateTime');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (101, 'GET_EA_LIST_RB', 'GET_EA_TEMP_LIST_RB', 'ft_RB');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (102, 'GET_EA_LIST_DLL', 'GET_EA_TEMP_LIST_DLL', 'ft_DLL');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (103, 'GET_EA_LIST_LNKH', 'GET_EA_TEMP_LIST_LNKH', 'ft_LinkHypotesis');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (104, 'GET_EA_LIST_LNKP', 'GET_EA_TEMP_LIST_LNKP', 'ft_LinkPragma');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (105, 'GET_EA_LIST_SECUR', NULL, 'ft_Security');

COMMIT WORK;

INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (7, 7, 'SHORT', 'SMALLINT', NULL, 0, NULL, NULL, NULL, 'короткое целое от -32767 до 32768');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (16, 16, 'INT64', 'BIGINT', NULL, 0, NULL, 0, NULL, 'большое целое от -9223372036854775807 до 9223372036854775808');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (10, 10, 'FLOAT', 'FLOAT', NULL, 0, NULL, NULL, NULL, 'вещественное одинарной точности');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (27, 27, 'DOUBLE', 'DOUBLE', NULL, 0, NULL, NULL, NULL, 'вещественное двойной точности');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (17, 16, 'INT64', 'NUMERIC', NULL, -2, 1, 15, NULL, 'NUMERIC');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (18, 16, 'INT64', 'DECIMAL', NULL, -2, 2, 15, NULL, 'DECIMAL');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (12, 12, 'DATE', 'DATE', NULL, 0, NULL, NULL, NULL, 'дата');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (13, 13, 'TIME', 'TIME', NULL, 0, NULL, NULL, NULL, 'время');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (35, 35, 'TIMESTAMP', 'TIMESTAMP', NULL, 0, NULL, NULL, NULL, 'дата со временем');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (14, 14, 'TEXT', 'CHAR', 10, 0, NULL, NULL, NULL, 'строка,дополненная пробелами до своей длины');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (37, 37, 'VARYING', 'VARCHAR', 10, 0, NULL, NULL, NULL, 'строка');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (261, 261, 'BLOB', 'BLOB', NULL, 0, 0, NULL, 4096, 'большой бинарный объект (рисунок, файл и т.п.)');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (262, 261, 'BLOB', 'BLOB', NULL, 0, 1, NULL, 4096, 'большой текстовый объект');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (1, 1, 'FK', 'FK', NULL, NULL, NULL, NULL, NULL, 'ссылка на справочник');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (8, 8, 'INTEGER', 'INTEGER', NULL, 0, NULL, NULL, NULL, 'целое');

COMMIT WORK;

INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10002, 24, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10006, 23, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10016, 23, '2010-09-12 16:36:59');
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10038, 91, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10039, 91, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10046, 91, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10050, 91, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10062, 94, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10063, 94, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10064, 94, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10065, 95, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10066, 95, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10070, 92, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10074, 92, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10075, 92, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10080, 95, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10081, 94, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10082, 94, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10083, 94, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10084, 95, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10085, 31, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10097, 71, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10101, 70, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10102, 27, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10105, 27, NULL);
INSERT INTO HYPOTESIS (ID, ID_EIDOS, DATE_DELETE) VALUES (10112, 82, NULL);

COMMIT WORK;

INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (1, 0, 0);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (2, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (3, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (4, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (5, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (20, 0, 2);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (21, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (22, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (23, 0, 21);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (24, 0, 21);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (25, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (27, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (28, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (30, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (31, 0, 22);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (32, 0, 22);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (50, 0, 2);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (60, 0, 2);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (61, 0, 60);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (62, 0, 60);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (63, 0, 60);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (70, 0, 3);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (71, 0, 3);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (72, 0, 3);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (80, 0, 4);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (81, 0, 4);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (82, 0, 81);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (90, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (91, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (92, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (93, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (94, 0, 93);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (95, 0, 93);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10002, 1, 24);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10003, 2, 10002);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10006, 1, 23);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10008, 2, 10006);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10011, 2, 10006);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10014, 2, 10006);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10016, 1, 23);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10038, 1, 91);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10039, 1, 91);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10046, 1, 91);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10050, 1, 91);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10062, 1, 94);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10063, 1, 94);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10064, 1, 94);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10065, 1, 95);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10066, 1, 95);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10070, 1, 92);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10074, 1, 92);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10075, 1, 92);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10080, 1, 95);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10081, 1, 94);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10082, 1, 94);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10083, 1, 94);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10084, 1, 95);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10085, 1, 31);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10088, 2, 10085);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10092, 2, 10085);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10096, 2, 10085);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10097, 1, 71);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10099, 2, 10097);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10100, 2, 10097);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10101, 1, 70);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10102, 1, 27);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10105, 1, 27);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10108, 2, 10105);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10112, 1, 82);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10113, 2, 10101);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10114, 2, 10112);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (10115, 2, 10112);

COMMIT WORK;

INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (1, 1, 'SYSDBA');
INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (2, 2, 'SYSDBA');
INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (3, 3, 'SYSDBA');
INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (4, 2, 'test');

COMMIT WORK;

INSERT INTO MULTIPLEXLNK (ID, ID_LINK, ID_HEADER) VALUES (10018, 10003, 10005);
INSERT INTO MULTIPLEXLNK (ID, ID_LINK, ID_HEADER) VALUES (10019, 10003, 10005);
INSERT INTO MULTIPLEXLNK (ID, ID_LINK, ID_HEADER) VALUES (10073, 10014, 10005);
INSERT INTO MULTIPLEXLNK (ID, ID_LINK, ID_HEADER) VALUES (10035, 10003, 10004);

COMMIT WORK;

INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10003, 24, 10002, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10008, 23, 10006, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10011, 23, 10006, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10014, 23, 10006, '2010-09-12 16:36:39');
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10088, 31, 10085, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10092, 31, 10085, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10096, 31, 10085, '2013-11-04 20:26:30');
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10099, 71, 10097, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10100, 71, 10097, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10108, 27, 10105, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10113, 70, 10101, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10114, 82, 10112, NULL);
INSERT INTO PRAGMA (ID, ID_EIDOS, ID_HYPOTESIS, DATE_DELETE) VALUES (10115, 82, 10112, NULL);

COMMIT WORK;

INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10007, 10006, '2009-05-28 19:54:18', 2009);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10009, 10008, '2009-05-28 19:54:37', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10010, 10008, '2009-05-28 19:54:37', 2016);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10012, 10011, '2009-05-28 19:56:09', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10013, 10011, '2009-05-28 19:56:09', 2016);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10015, 10014, '2009-05-28 19:56:17', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10017, 10016, '2009-05-29 20:48:29', 2009);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10040, 10014, '2010-02-14 12:55:45', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10041, 10011, '2010-02-14 12:55:54', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10042, 10008, '2010-02-14 12:56:01', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10043, 10016, '2010-02-14 12:56:28', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10044, 10006, '2010-02-14 12:56:57', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10045, 10016, '2010-02-14 12:57:08', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10047, 10014, '2010-02-14 13:05:11', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10048, 10002, '2010-02-14 13:26:59', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10049, 10002, '2010-02-14 13:26:59', 2009);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10051, 10003, '2010-02-14 13:28:44', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10052, 10003, '2010-02-14 13:28:44', 2016);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10053, 10003, '2010-02-14 13:28:44', 2015);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10054, 10003, '2010-02-14 13:28:44', 2011);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10055, 10003, '2010-02-14 13:28:44', 2020);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10056, 10003, '2010-02-14 13:28:51', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10059, 10008, '2010-02-14 14:54:57', 2015);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10060, 10008, '2010-02-14 14:54:57', 2013);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10061, 10008, '2010-02-14 14:54:57', 2011);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10067, 10008, '2010-02-14 14:59:08', 2016);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10068, 10008, '2010-02-14 14:59:08', 2014);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10069, 10008, '2010-02-14 14:59:08', 2012);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10071, 10008, '2010-02-14 15:01:00', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10072, 10003, '2010-02-14 15:04:13', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10076, 10014, '2010-07-12 19:58:23', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10077, 10011, '2010-07-12 19:58:36', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10078, 10008, '2010-07-12 20:16:42', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10079, 10003, '2010-07-12 21:31:35', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10086, 10085, '2013-11-04 20:22:37', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10087, 10085, '2013-11-04 20:22:37', 2009);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10089, 10088, '2013-11-04 20:24:13', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10090, 10088, '2013-11-04 20:24:13', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10091, 10088, '2013-11-04 20:24:13', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10093, 10092, '2013-11-04 20:25:04', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10094, 10092, '2013-11-04 20:25:04', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10095, 10092, '2013-11-04 20:25:04', 2001);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10103, 10102, '2013-11-04 20:34:22', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10104, 10102, '2013-11-04 20:34:22', 2009);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10106, 10105, '2013-11-04 20:35:09', 2009);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10107, 10105, '2013-11-04 20:35:25', 2010);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10109, 10108, '2013-11-04 20:36:25', 2008);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10110, 10108, '2013-11-04 20:36:25', 2007);
INSERT INTO TEMPORALITY (ID, ID_LINK, DATE_TIME, ID_HEADER) VALUES (10111, 10108, '2013-11-04 20:36:25', 2001);

COMMIT WORK;

INSERT INTO USERS (UID, NAME, ID_TYPE_ACCES_RIGHT, FULL_NAME, DESCRIPTIONS, IS_DELETED, IS_DISABLED) VALUES (9, 'SYSDBA', 28, 'Администратор БД', '', 0, 0);

COMMIT WORK;

INSERT INTO VAR_DT (USER_NAME, DT) VALUES ('SYSDBA', '2019-08-16 20:29:09');

COMMIT WORK;



/******************************************************************************/
/***                           Check constraints                            ***/
/******************************************************************************/

ALTER TABLE IRB_RESOURCES ADD CONSTRAINT CHK_IRB_RESOURCES check (((ID_PARENT =-1) OR ( ID_PARENT = ANY(SELECT ID FROM IRB_RESOURCES) )) and ID_PARENT<>ID);
ALTER TABLE ID_OBJ ADD CHECK (TYPE_OBJ=0 or TYPE_OBJ=1 or TYPE_OBJ=2);
ALTER TABLE EIDOS ADD CONSTRAINT CHK_EIDOS_PARENT check (((ID_PARENT=0) OR ( ID_PARENT = ANY(SELECT ID FROM EIDOS) )) and ID_PARENT<>ID);
ALTER TABLE ID_OBJ ADD check (((ID_PARENT=0) OR ( ID_PARENT = ANY(SELECT ID FROM ID_OBJ) )) and ID_PARENT<>ID);
ALTER TABLE IRB_STRUCTURES ADD CONSTRAINT CHK_IRB_STRUCTURES check (((ID_PARENT=0) OR ( ID_PARENT = ANY(SELECT ID FROM IRB_STRUCTURES) )) and ID_PARENT<>ID);
ALTER TABLE IRB_PLACESUSE ADD CONSTRAINT CHK_IRB_PLACESUSE check (((ID_PARENT is NULL) OR ( ID_PARENT = ANY(SELECT ID FROM IRB_PLACESUSE) )) and ID_PARENT<>ID);
ALTER TABLE IBE$TODO ADD CHECK ((ITEM_PRIORITY >=0) AND (ITEM_PRIORITY <=5));
ALTER TABLE IBE$TODO ADD CHECK (ITEM_STATE IN (0, 1));


/******************************************************************************/
/***                           Unique constraints                           ***/
/******************************************************************************/

ALTER TABLE ID_OBJ ADD CONSTRAINT UNQ_ID_OBJ UNIQUE (ID);
ALTER TABLE USERS ADD UNIQUE (NAME);
ALTER TABLE VAR_DT ADD CONSTRAINT UNQ_VAR_DT UNIQUE (USER_NAME);


/******************************************************************************/
/***                              Primary keys                              ***/
/******************************************************************************/

ALTER TABLE ACCESS_RIGHT ADD CONSTRAINT PK_ACCESS_RIGHT PRIMARY KEY (ID);
ALTER TABLE ACL ADD CONSTRAINT PK_ACL PRIMARY KEY (ID);
ALTER TABLE EIDOS ADD CONSTRAINT PK_EIDOS PRIMARY KEY (ID);
ALTER TABLE ETC ADD CONSTRAINT PK_ETC PRIMARY KEY (ID);
ALTER TABLE ETC_PARAMETERS ADD CONSTRAINT PK_ETC_PARAMETERS PRIMARY KEY (ID);
ALTER TABLE EXTRAATRIB_RB ADD CONSTRAINT PK_EXTRAATRIB_RB PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_DLL ADD CONSTRAINT PK_EXTRAATTRIB_DLL PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_HEADER ADD CONSTRAINT PK_EXTRAATTRIB_HEADER PRIMARY KEY (ID);
ALTER TABLE EXTRAATTRIB_LNK ADD CONSTRAINT PK_EXTRAATTRIB_LNK PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_DATE ADD CONSTRAINT PK_EXTRAATTRIB_SIM_DATE PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_INT ADD CONSTRAINT PK_EXTRAATTRIB_SIM_INT PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_NUM ADD CONSTRAINT PK_EXTRAATTRIB_SIM_NUM PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_STR ADD CONSTRAINT PK_EXTRAATTRIB_SIM_STR PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE GROUPS ADD CONSTRAINT PK_GROUPS PRIMARY KEY (ID);
ALTER TABLE HYPOTESIS ADD CONSTRAINT PK_HYPOTESIS PRIMARY KEY (ID);
ALTER TABLE IBE$TODO ADD PRIMARY KEY (ITEM_ID);
ALTER TABLE IRB_HUMANS ADD CONSTRAINT PK_IRB_HUMANS PRIMARY KEY (ID);
ALTER TABLE IRB_OPERATIONS ADD CONSTRAINT PK_IRB_OPERATIONS PRIMARY KEY (ID);
ALTER TABLE IRB_PLACESUSE ADD CONSTRAINT PK_IRB_PLACESUSE PRIMARY KEY (ID);
ALTER TABLE IRB_RESOURCES ADD CONSTRAINT PK_IRB_RESOURCES PRIMARY KEY (ID);
ALTER TABLE IRB_STRUCTURES ADD CONSTRAINT PK_IRB_STRUCTURES PRIMARY KEY (ID);
ALTER TABLE IRB_UNITMESUREMENT ADD CONSTRAINT PK_IRB_UNITMESUREMENT PRIMARY KEY (ID);
ALTER TABLE MEMBERSHIP ADD CONSTRAINT PK_MEMBERSHIP PRIMARY KEY (ID);
ALTER TABLE MULTIPLEXLNK ADD CONSTRAINT PK_MULTIPLEXLNK PRIMARY KEY (ID);
ALTER TABLE PRAGMA ADD CONSTRAINT PK_PRAGMA PRIMARY KEY (ID);
ALTER TABLE RB_DESCRIBER ADD CONSTRAINT PK_RB_DESCRIBER PRIMARY KEY (ID);
ALTER TABLE TEMPORALITY ADD CONSTRAINT PK_TEMPORALITY PRIMARY KEY (ID);
ALTER TABLE USERS ADD PRIMARY KEY (UID);


/******************************************************************************/
/***                              Foreign keys                              ***/
/******************************************************************************/

ALTER TABLE ACL ADD CONSTRAINT FK_ACL FOREIGN KEY (ACCESS_RIGHT) REFERENCES ACCESS_RIGHT (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACL ADD CONSTRAINT FK_ACL_GID FOREIGN KEY (GID) REFERENCES GROUPS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ETC_PARAMETERS ADD CONSTRAINT FK_ETC_PARAMETERS FOREIGN KEY (ID_OBJECT) REFERENCES ETC (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE HYPOTESIS ADD CONSTRAINT FK_HYPOTESIS FOREIGN KEY (ID_EIDOS) REFERENCES EIDOS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE IRB_HUMANS ADD CONSTRAINT FK_IRB_HUMANS FOREIGN KEY (LNK_ORGANIZATION) REFERENCES IRB_STRUCTURES (ID);
ALTER TABLE IRB_RESOURCES ADD CONSTRAINT FK_IRB_RESOURCES_LNK_UNITMESUR FOREIGN KEY (LNK_UNITMESUR) REFERENCES IRB_UNITMESUREMENT (ID);
ALTER TABLE IRB_STRUCTURES ADD CONSTRAINT FK_IRB_STRUCTURES FOREIGN KEY (LNK_HUMANS_CHIEF) REFERENCES IRB_HUMANS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MEMBERSHIP ADD CONSTRAINT FK_MEMBERSHIP FOREIGN KEY (GID) REFERENCES GROUPS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PRAGMA ADD CONSTRAINT FK_PRAGMA FOREIGN KEY (ID_HYPOTESIS) REFERENCES HYPOTESIS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TEMPORALITY ADD CONSTRAINT FK_TEMPORALITY FOREIGN KEY (ID_HEADER) REFERENCES EXTRAATTRIB_HEADER (ID) ON DELETE CASCADE ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX ACL_IDX_GID ON ACL (GID);
CREATE INDEX ACL_IDX_ID_OBJECT ON ACL (ID_OBJECT);
CREATE INDEX EIDOS_IDX1 ON EIDOS (ID_PARENT);
CREATE INDEX ETC_IDX_USER ON ETC (ID_USER);
CREATE INDEX ETC_PARAMETERS_IDX1 ON ETC_PARAMETERS (ID, ID_OBJECT);
CREATE INDEX IDX_EXTRAATRIB_RB_ID_HEADER ON EXTRAATRIB_RB (ID_HEADER);
CREATE INDEX IDX_EXTRAATRIB_RB_VAL ON EXTRAATRIB_RB ("VALUE");
CREATE UNIQUE INDEX IDX_EXTRAATTRIB_ALTCAPTION1 ON EXTRAATTRIB_ALTCAPTION (ID_EIDOS, ID_HEADER);
CREATE INDEX EXTRAATTRIB_HEADER_IDX1 ON EXTRAATTRIB_HEADER (ID_CLASS);
CREATE INDEX IDX_EXTRAATTRIB_HEADER_FIELDNAM ON EXTRAATTRIB_HEADER (FIELDNAME);
CREATE INDEX EXTRAATTRIB_SIM_STR_IDX1 ON EXTRAATTRIB_SIM_STR (ID_LINK);
CREATE UNIQUE INDEX EXTRAATTRIB_SUPPORT_IDX1 ON EXTRAATTRIB_SUPPORT (FIELDTYPE);
CREATE INDEX HYPOTESIS_IDX1 ON HYPOTESIS (ID_EIDOS);
CREATE INDEX IBE$TODO_BY_OBJECTNAME ON IBE$TODO (OBJECT_NAME);
CREATE INDEX ID_OBJ_IDX1 ON ID_OBJ (ID_PARENT);
CREATE INDEX ID_OBJ_IDX_ID ON ID_OBJ (ID);
CREATE INDEX ID_OBJ_TYPE_OBJ ON ID_OBJ (TYPE_OBJ);
CREATE INDEX MEMBERSHIP_IDX_GID ON MEMBERSHIP (GID);
CREATE INDEX MEMBERSHIP_IDX_USER ON MEMBERSHIP (USER_NAME);
CREATE INDEX TEMPORALITY_IDX1 ON TEMPORALITY (ID_LINK);
CREATE DESCENDING INDEX TEMPORALITY_IDX2 ON TEMPORALITY (DATE_TIME);
CREATE INDEX TEMPORALITY_IDX3 ON TEMPORALITY (ID_HEADER);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/



SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: ACCESS_RIGHT_BI */
CREATE TRIGGER ACCESS_RIGHT_BI FOR ACCESS_RIGHT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ACCESS_RIGHT_ID,1);
END
^

/* Trigger: ACL_BI */
CREATE TRIGGER ACL_BI FOR ACL
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ACL_ID,1);
END
^

/* Trigger: EIDOS_AD_DELETE_FROM_ACL */
CREATE TRIGGER EIDOS_AD_DELETE_FROM_ACL FOR EIDOS
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from id_obj where id=old.id;
  delete from ACL where ACL.id_object=old.id;
end
^

/* Trigger: EIDOS_AI_SET_DEF_RIGHT */
CREATE TRIGGER EIDOS_AI_SET_DEF_RIGHT FOR EIDOS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  insert into id_obj(id,type_obj,id_parent)  values(new.id,0,new.id_parent);
  insert into ACL(GID,access_right, id_object)
  SELECT ACL.GID, ACL.ACCESS_RIGHT,new.id
FROM ACL
WHERE 
   (
      (ACL.ID_OBJECT = new.id_parent)
   );
end
^

/* Trigger: EIDOS_AU0 */
CREATE TRIGGER EIDOS_AU0 FOR EIDOS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if((new.id<>old.id) or (new.id_parent<>old.id_parent) ) then
    update id_obj set id=new.id,id_parent=new.id_parent where id=old.id;
end
^

/* Trigger: EIDOS_BI0 */
CREATE TRIGGER EIDOS_BI0 FOR EIDOS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 IF (NEW.ID IS NULL) THEN
  NEW.ID = GEN_ID(GEN_ID_ALL,1);
end
^

/* Trigger: EIDOS_BI0_SET_LEVEL */
CREATE TRIGGER EIDOS_BI0_SET_LEVEL FOR EIDOS
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
DECLARE VARIABLE l INTEGER;
begin
if (new.id_parent>0) then
 select eidos."LEVEL"+1 from eidos where eidos.id=new.id_parent into :l;
else l=1;
 new."LEVEL"=:l;
end
^

/* Trigger: ETC_ID_AUTOINCREMENT */
CREATE TRIGGER ETC_ID_AUTOINCREMENT FOR ETC
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ETC,1);
END
^

/* Trigger: ETC_PARAMETERS_ID_AUTOINCREMENT */
CREATE TRIGGER ETC_PARAMETERS_ID_AUTOINCREMENT FOR ETC_PARAMETERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ETC,1);
END
^

/* Trigger: EXTRAATTRIB_HEADER_BI0 */
CREATE TRIGGER EXTRAATTRIB_HEADER_BI0 FOR EXTRAATTRIB_HEADER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: GROUPS_BI */
CREATE TRIGGER GROUPS_BI FOR GROUPS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_GROUPS_ID,1);
END
^

/* Trigger: HYPOTESIS_AD_DELETE_FROM_ACL */
CREATE TRIGGER HYPOTESIS_AD_DELETE_FROM_ACL FOR HYPOTESIS
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from id_obj where id=old.id;
  delete from ACL where ACL.id_object=old.id;
end
^

/* Trigger: HYPOTESIS_AI_SET_DEF_RIGHT */
CREATE TRIGGER HYPOTESIS_AI_SET_DEF_RIGHT FOR HYPOTESIS
ACTIVE AFTER INSERT POSITION 0
AS
begin
   insert into id_obj(id,type_obj,id_parent)  values(new.id,1,new.id_eidos);
   insert into ACL(GID,access_right, id_object)
    SELECT ACL.GID, ACL.ACCESS_RIGHT,new.id
        FROM ACL
    WHERE 
    (
        (ACL.ID_OBJECT = new.id_eidos)
    );
end
^

/* Trigger: HYPOTESIS_AU0 */
CREATE TRIGGER HYPOTESIS_AU0 FOR HYPOTESIS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if((new.id<>old.id) or (new.id_eidos<>old.id_eidos) ) then
    update id_obj set id=new.id,id_parent=new.id_eidos where id=old.id;
end
^

/* Trigger: HYPOTESIS_BI0 */
CREATE TRIGGER HYPOTESIS_BI0 FOR HYPOTESIS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 IF (NEW.ID IS NULL) THEN
  NEW.ID = GEN_ID(GEN_ID_ALL,1);
end
^

/* Trigger: IBE$TODO_ITEM_ID_BI */
CREATE TRIGGER IBE$TODO_ITEM_ID_BI FOR IBE$TODO
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.item_id IS NULL) THEN
    NEW.item_id = GEN_ID(ibe$todo_item_id_gen,1);
  NEW.item_timestamp = 'now';
  NEW.item_state = 0;
  NEW.item_owner = USER;
  IF (NEW.item_priority IS NULL) THEN
    NEW.item_priority = 0;
END
^

/* Trigger: ID_OBJ_BD0 */
CREATE TRIGGER ID_OBJ_BD0 FOR ID_OBJ
ACTIVE BEFORE DELETE POSITION 0
AS
DECLARE VARIABLE ID INTEGER;
begin
  if (old.type_obj=0) then select id from eidos where id=old.id into :id;
  if (old.type_obj=1) then select id from hypotesis where id=old.id into :id;
  if (old.type_obj=0) then select id from pragma where id=old.id into :id;
  if (:id is not NULL) then exception DELETE_ERROR;
end
^

/* Trigger: ID_OBJ_BI0 */
CREATE TRIGGER ID_OBJ_BI0 FOR ID_OBJ
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
DECLARE VARIABLE ID INTEGER;
begin
  if (new.type_obj=0) then select id from eidos where id=new.id and id_parent=new.id_parent into :id;
  if (new.type_obj=1) then select id from hypotesis where id=new.id and id_eidos=new.id_parent into :id;
  if (new.type_obj=2) then select id from pragma where id=new.id and id_hypotesis=new.id_parent into :id;
  if (:id is NULL) then exception INSERT_ERROR;
end
^

/* Trigger: IRB_HUMANS_BI */
CREATE TRIGGER IRB_HUMANS_BI FOR IRB_HUMANS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_OPERATIONS_BI */
CREATE TRIGGER IRB_OPERATIONS_BI FOR IRB_OPERATIONS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_PLACESUSE_BI */
CREATE TRIGGER IRB_PLACESUSE_BI FOR IRB_PLACESUSE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_RESOURCES_BI */
CREATE TRIGGER IRB_RESOURCES_BI FOR IRB_RESOURCES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_STUCTURES_BI */
CREATE TRIGGER IRB_STUCTURES_BI FOR IRB_STRUCTURES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_UNITMESUREMENT_BI */
CREATE TRIGGER IRB_UNITMESUREMENT_BI FOR IRB_UNITMESUREMENT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: MEMBERSHIP_BI */
CREATE TRIGGER MEMBERSHIP_BI FOR MEMBERSHIP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_MEMBERSHIP_ID,1);
END
^

/* Trigger: MULTIPLEXLNK_BI */
CREATE TRIGGER MULTIPLEXLNK_BI FOR MULTIPLEXLNK
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: PRAGMA_AD_DELETE_FROM_ACL */
CREATE TRIGGER PRAGMA_AD_DELETE_FROM_ACL FOR PRAGMA
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from id_obj where id=old.id;
  delete from ACL where ACL.id_object=old.id;
end
^

/* Trigger: PRAGMA_AI_SET_DEF_RIGHT */
CREATE TRIGGER PRAGMA_AI_SET_DEF_RIGHT FOR PRAGMA
ACTIVE AFTER INSERT POSITION 0
AS
begin
  insert into id_obj(id,type_obj,id_parent)  values(new.id,2,new.id_hypotesis);
  insert into ACL(GID,access_right, id_object)
    SELECT ACL.GID, ACL.ACCESS_RIGHT,new.id
    FROM ACL
    WHERE 
    (
      (ACL.ID_OBJECT = new.id_hypotesis)
    );
end
^

/* Trigger: PRAGMA_AU0 */
CREATE TRIGGER PRAGMA_AU0 FOR PRAGMA
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if((new.id<>old.id) or (new.id_hypotesis<>old.id_hypotesis) ) then
    update id_obj set id=new.id,id_parent=new.id_hypotesis where id=old.id;
end
^

/* Trigger: PRAGMA_BI */
CREATE TRIGGER PRAGMA_BI FOR PRAGMA
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: RB_DESCRIBER_BI */
CREATE TRIGGER RB_DESCRIBER_BI FOR RB_DESCRIBER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: TEMPORALITY_BI */
CREATE TRIGGER TEMPORALITY_BI FOR TEMPORALITY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: TRG_USERS_BI0 */
CREATE TRIGGER TRG_USERS_BI0 FOR USERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    NEW.UID = GEN_ID(GEN_ID_ALL,1);
END
^
SET TERM ; ^



/******************************************************************************/
/***                           Stored procedures                            ***/
/******************************************************************************/



SET TERM ^ ;

ALTER PROCEDURE CALCULATE_RES_REMAINDER (
    ID_LINK INTEGER)
AS
declare variable TMP_ID_PARENT integer;
declare variable ID_LNK_FORKEDRES integer;
declare variable TMP_HOSTID integer;
declare variable SUM_EXPENCE float;
declare variable ID_QUANTITY integer;
declare variable ID_REMAINDER integer;
declare variable RES_QUANTITY float;
declare variable RES_REMAINDER float;
declare variable COUNT_RECORDS integer;
begin
    
    /*Для работы процедуры получаем значения идентификаторов экстраатрибутов по их именам*/
    select ea_num_by_name.id_ea from ea_num_by_name('LNK_ForkedRES') into :id_lnk_forkedres;
    select ea_num_by_name.id_ea from ea_num_by_name('Quantity') into :id_quantity;
    select ea_num_by_name.id_ea from ea_num_by_name('Remainder') into :id_remainder;
    /*Получаем значение ресурса родителя для переданного в параметре идентификаторе копии ресурса*/
    SELECT t_LNK_ForkedRES.keyvalue
    FROM VA_PRAGMA LEFT JOIN GET_EA_LIST_LNKP(:id_lnk_forkedres) t_LNK_ForkedRES ON (t_LNK_ForkedRES.id_link=VA_PRAGMA.id)
    WHERE VA_PRAGMA.id = :id_link into :tmp_ID_Parent;
    /*Обработке подвергается только родительский объект, для чего определяем значение его идентификатора*/
    if(:tmp_ID_Parent >0) then tmp_hostid=tmp_id_parent; else tmp_hostid=id_link;
    /*Находим количество ресурса родительского объекта*/
    SELECT t_Quantity.MEANING
    FROM VA_PRAGMA
    LEFT JOIN GET_EA_LIST_NUM(:id_quantity) t_Quantity ON (t_Quantity.id_link=VA_PRAGMA.id)
    WHERE VA_PRAGMA.ID=:tmp_hostid
    INTO :res_quantity;
    /*Находим сумму истраченных ресурсов по родительскому идентификатору ресурса*/
    SELECT SUM(t_Quantity.MEANING)
    FROM VA_PRAGMA
    LEFT JOIN GET_EA_LIST_LNKP(:id_lnk_forkedres) t_LNK_ForkedRES ON (t_LNK_ForkedRES.id_link=VA_PRAGMA.id)
    LEFT JOIN GET_EA_LIST_NUM(:id_quantity) t_Quantity ON (t_Quantity.id_link=VA_PRAGMA.id)
    GROUP BY t_LNK_ForkedRES.keyvalue
    HAVING t_LNK_ForkedRES.keyvalue = :tmp_hostid
    INTO :sum_expence;
    /*Вычисляем остаток*/
    res_remainder=res_quantity-sum_expence;
    /*Записываем значение остатка в экстраатрибут*/
    /* Далее взят кусок процедуры сохранения экстраатрибута и создан аналог вызова
    execute procedure set_ea_simple_num(:id_remainder,:tmp_hostid,:res_remainder,:date_of_change);
    поскольку непосредственный вызов производит deadlock*/
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_NUM.id_link) from EXTRAATTRIB_SIM_NUM
    where (EXTRAATTRIB_SIM_NUM.id_link=:tmp_hostid and EXTRAATTRIB_SIM_NUM.id_header=:id_remainder)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_NUM
            (EXTRAATTRIB_SIM_NUM.id_header,EXTRAATTRIB_SIM_NUM.id_link, EXTRAATTRIB_SIM_NUM."VALUE")
            values (:id_remainder,:tmp_hostid,:res_remainder);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_NUM set EXTRAATTRIB_SIM_NUM."VALUE"=:res_remainder
            where EXTRAATTRIB_SIM_NUM.id_header=:id_remainder and EXTRAATTRIB_SIM_NUM.id_link=:tmp_hostid;
        end
  --suspend;
end^


ALTER PROCEDURE DEL_ALL_EA_BYOBJID (
    ID_LINK INTEGER)
AS
begin
        /*Проходим последовательно по всем таблицам экстраатрибутов и удаляем все что находится по данному ID*/
        delete from extraatrib_rb where extraatrib_rb.id_link=:id_link;
        delete from extraattrib_dll where extraattrib_dll.id_link=:id_link;
        delete from extraattrib_sim_date where extraattrib_sim_date.id_link=:id_link;
        delete from extraattrib_sim_int where extraattrib_sim_int.id_link=:id_link;
        delete from extraattrib_sim_num where extraattrib_sim_num.id_link=:id_link;
        delete from extraattrib_sim_str where extraattrib_sim_str.id_link=:id_link;
        delete from extraattrib_lnk where extraattrib_lnk.id_link=:id_link;
        /*Проходим последовательно по всем таблицам экстраатрибутов и удаляем все что находится по данному ID, связанному с темпоральностью*/
        delete from extraatrib_rb where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_dll where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_date where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_int where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_num where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_str where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_lnk where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        /*Удаляем все ссылки привязаные к удаляемому объекту в самой таблице темпоральности*/
        delete from temporality where temporality.id_link=:id_link;
  suspend;
end^


ALTER PROCEDURE DEL_EA_ALTCAPTION (
    ID_EIDOS INTEGER,
    ID_HEADER INTEGER)
AS
BEGIN
    delete from EXTRAATTRIB_ALTCAPTION where EXTRAATTRIB_ALTCAPTION.ID_EIDOS=:ID_EIDOS and EXTRAATTRIB_ALTCAPTION.ID_HEADER=:ID_HEADER;
END^


ALTER PROCEDURE DEL_EA_MULTILNK_LINE (
    ID_EA INTEGER,
    LINE_ID INTEGER)
AS
BEGIN
--Процедура удаляет одно вхождение многострочной ссылки объекта    
delete from EXTRAATTRIB_LNK where EXTRAATTRIB_LNK.ID_HEADER=:ID_EA and EXTRAATTRIB_LNK.ID_LINK=:LINE_ID;
delete from MULTIPLEXLNK where MULTIPLEXLNK.ID=:LINE_ID;
  
END^


ALTER PROCEDURE DEL_EIDOS (
    ID_IN INTEGER)
AS
declare variable DT timestamp;
begin
  /* Процедура помечает к удалению запись в таблице EIDOS по ID переданному в параметре */
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  update EIDOS set EIDOS.date_delete=:dt where EIDOS.id=:id_in;
  suspend;
end^


ALTER PROCEDURE DEL_HYPOTESIS (
    ID_IN INTEGER)
AS
declare variable DT timestamp;
begin
  /* Процедура помечает к удалению запись в таблице EIDOS по ID переданному в параметре */
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  update HYPOTESIS set HYPOTESIS.date_delete=:dt where HYPOTESIS.id=:id_in;
  suspend;
end^


ALTER PROCEDURE DEL_PRAGMA (
    ID_IN INTEGER)
AS
declare variable DT timestamp;
begin
  /* Процедура помечает к удалению запись в таблице EIDOS по ID переданному в параметре */
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  update PRAGMA set PRAGMA.date_delete=:dt where PRAGMA.id=:id_in;
  suspend;
end^


ALTER PROCEDURE DEL_REGED_DLL (
    DLL_NAME4DELETE VARCHAR(255))
AS
BEGIN
    delete from DLL_MD5 where DLL_MD5.DLL_NAME=:DLL_NAME4delete;
END^


ALTER PROCEDURE EA_NUM_BY_NAME (
    FIELDNAME VARCHAR(64))
RETURNS (
    ID_EA INTEGER)
AS
begin
  /* Procedure Text */
  select first 1 extraattrib_header.id from  extraattrib_header where UPPER(extraattrib_header.fieldname)=upper(:fieldname)
  into :id_ea;
  suspend;
end^


ALTER PROCEDURE GET_EA_ALTCAPTIONS (
    ID_EIDOS INTEGER)
RETURNS (
    ID_HEADER INTEGER,
    NEWCAPTION VARCHAR(255))
AS
begin
      FOR
      SELECT EXTRAATTRIB_ALTCAPTION.ID_HEADER,EXTRAATTRIB_ALTCAPTION.newcaption
      FROM EXTRAATTRIB_ALTCAPTION
      where EXTRAATTRIB_ALTCAPTION.id_eidos=:id_eidos
      INTO
        :id_header,:newcaption
      do
      begin 
          suspend;
      end
end^


ALTER PROCEDURE GET_EA_ATTRIBUTES_BYNUM (
    FIELDNUM INTEGER)
RETURNS (
    ID INTEGER,
    ID_CLASS INTEGER,
    FIELDNAME VARCHAR(64),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    LINKEDLEVELHP INTEGER,
    LINKEDOBJACT INTEGER,
    VISIBLE INTEGER,
    MULTILNK INTEGER)
AS
begin
  /* Procedure Text */
  select first 1
    extraattrib_header.id,
    extraattrib_header.id_class,
    extraattrib_header.fieldname,
    extraattrib_header.fieldtype,
    extraattrib_header.id_belongfor,
    extraattrib_header.id_rb_describer,
    extraattrib_header.dll_filename,
    extraattrib_header.dll_procname,
    extraattrib_header.temporality,
    extraattrib_header.required,
    extraattrib_header.linkedlevelhp,
    extraattrib_header.linkedobjact,
    extraattrib_header.visible,
    extraattrib_header.multilnk

    from  extraattrib_header
    where extraattrib_header.id=:fieldnum
  into
    :id,
    :id_class,
    :fieldname,
    :fieldtype,
    :id_belongfor,
    :id_rb_describer,
    :dll_filename,
    :dll_procname,
    :temporality,
    :required,
    :linkedlevelhp,
    :linkedobjact,
    :visible,
    :multilnk
    ;

  suspend;
end^


ALTER PROCEDURE GET_EA_LIST_DATE (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING TIMESTAMP,
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
     begin
     FOR
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_DATE."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_DATE
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_DATE.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_DATE.id_link,EXTRAATTRIB_SIM_DATE."VALUE"
        FROM EXTRAATTRIB_SIM_DATE
        WHERE 
          (
            (EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_DLL (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE VARCHAR(255))
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
    begin
     FOR
        SELECT s.ID_LINK, EXTRAATTRIB_DLL."VALUE",EXTRAATTRIB_DLL.keyvalue   --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_DLL
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_DLL.id_link)

        WHERE 
          (
            (EXTRAATTRIB_DLL.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_DLL.id_link,EXTRAATTRIB_DLL."VALUE",EXTRAATTRIB_DLL.keyvalue
        FROM EXTRAATTRIB_DLL
        WHERE 
          (
            (EXTRAATTRIB_DLL.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_INT (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
     begin
     FOR
        /*SELECT TEMPORALITY.ID_LINK, EXTRAATTRIB_SIM_INT."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_INT
            INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_INT.ID_LINK = TEMPORALITY.ID)
            INNER JOIN VW_LAST_SIMPLVALUE ON (TEMPORALITY.ID_LINK = VW_LAST_SIMPLVALUE.ID_LINK) AND (TEMPORALITY.DATE_TIME = VW_LAST_SIMPLVALUE.LAST_DATE)
        WHERE 
          (
            (EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
          )*/
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_INT."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_INT
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_INT.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_INT.id_link,EXTRAATTRIB_SIM_INT."VALUE"
        FROM EXTRAATTRIB_SIM_INT
        WHERE 
          (
            (EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_LNKH (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_MULTITABLE INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE HYPOTESISNAMEID INTEGER;
DECLARE VARIABLE IS_MULTILNK INTEGER;
begin
/*
Получаем необходимые значения для внутренних перемеенных
*/
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  SELECT EXTRAATTRIB_HEADER.multilnk FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_multilnk;

  if (:is_multilnk=1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
--Блок для темпоральных значений
  if(:is_temporality=1) then

    begin
     FOR
        SELECT s.ID_LINK, get_ea_list_str.meaning,EXTRAATTRIB_LNK.keyvalue,EXTRAATTRIB_LNK.ratio
            FROM EXTRAATTRIB_LNK
            left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_LNK.id_link)
        WHERE
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    do
        begin
            SUSPEND;
        end
   end

  else
--Блок простых значений
  begin
    FOR
        SELECT EXTRAATTRIB_LNK.id_link,get_ea_list_str.meaning,EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio
        FROM EXTRAATTRIB_LNK left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
        WHERE 
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_LNKP (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT)
AS
declare variable IS_TEMPORALITY integer;
declare variable HYPOTESISNAMEID integer;
declare variable PRAGMADATEID integer;
declare variable IS_MULTILNK integer;
begin
/*
Получаем необходимые значения для внутренних перемеенных
*/
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  SELECT EXTRAATTRIB_HEADER.multilnk FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_multilnk;

  if (:is_multilnk=1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('PragmaDate') into :PRAGMADATEID;
--Блок для темпоральных значений
  if(:is_temporality=1) then

    begin
     FOR
        SELECT s.ID_LINK,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning),
                EXTRAATTRIB_LNK.keyvalue,
                EXTRAATTRIB_LNK.ratio

            FROM EXTRAATTRIB_LNK
            left join va_pragma on (EXTRAATTRIB_LNK.keyvalue=va_pragma.id)
            left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (va_pragma.id_hypotesis=hypName.id_link)
            left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (EXTRAATTRIB_LNK.keyvalue=PragmaDate.id_link)
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_LNK.id_link)
        WHERE
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    do
        begin
            SUSPEND;
        end
   end

  else
--Блок простых значений
  begin
    FOR
        SELECT EXTRAATTRIB_LNK.id_link,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning),
                EXTRAATTRIB_LNK.keyvalue,
                EXTRAATTRIB_LNK.ratio
        FROM EXTRAATTRIB_LNK
        left join va_pragma on (EXTRAATTRIB_LNK.keyvalue=va_pragma.id)
        left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (va_pragma.id_hypotesis=hypName.id_link)
        left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (EXTRAATTRIB_LNK.keyvalue=PragmaDate.id_link)
        WHERE 
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_MULTILNKH (
    ID_EA_HEADER INTEGER,
    ID_OWNER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID INTEGER)
AS
declare variable IS_MULTILNK integer;
declare variable COUNTERH integer;
declare variable COUNTERP integer;
declare variable ID_EIDOS integer;
begin
/*
Получаем необходимые значения для внутренних переменных
*/
    select EXTRAATTRIB_HEADER.multilnk from EXTRAATTRIB_HEADER
    where (id = :id_ea_header) into :is_multilnk;

    if (:is_multilnk <> 1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

    select count(ID) from VA_HYPOTESIS where ID=:ID_Owner into :counterH;
    select count(ID) from VA_PRAGMA where ID=:ID_Owner into :counterP;
    
    if (counterP=0 and counterH=0) then  exception NEVER_PARAMS_VALUES;--Ошибка во входном атрибуте - нет такого объекта среди изветсных 
    for
        select multiplexlnk.id_link, EXTRAATTRIB_LNK.keyvalue,EXTRAATTRIB_LNK.ratio, multiplexlnk.id
        from EXTRAATTRIB_LNK
        inner join multiplexlnk on (multiplexlnk.ID = EXTRAATTRIB_LNK.id_link)                              --только по совпадающим атрибутам с таблицей мультилинка
        inner join va_hypotesis on (EXTRAATTRIB_LNK.keyvalue = va_hypotesis.id)                                   --и только по гипотезам
        where (EXTRAATTRIB_LNK.id_header=:id_ea_header and multiplexlnk.id_link=:ID_Owner)                  --для объекта, идентификатор которого передан в параметре
        into
            :id_link,
            :keyvalue,
            :ratio,
            :id
    do
    begin
        select first 1 id_eidos from va_hypotesis where id=:keyvalue into :ID_EIDOS;
        select first 1 get_hypotesis_name_list.meaning from get_hypotesis_name_list(:ID_EIDOS) where get_hypotesis_name_list.id=:keyvalue into :meaning;
        suspend;
    end
end^


ALTER PROCEDURE GET_EA_LIST_MULTILNKP (
    ID_EA_HEADER INTEGER,
    ID_OWNER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID INTEGER)
AS
declare variable IS_MULTILNK integer;
declare variable COUNTERH integer;
declare variable COUNTERP integer;
begin
/*
Получаем необходимые значения для внутренних переменных
*/
    select EXTRAATTRIB_HEADER.multilnk from EXTRAATTRIB_HEADER
    where (id = :id_ea_header) into :is_multilnk;

    if (:is_multilnk <> 1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

    select count(VA_HYPOTESIS.ID) from VA_HYPOTESIS where VA_HYPOTESIS.ID=:ID_Owner into :counterH;
    select count(VA_PRAGMA.ID) from VA_PRAGMA where VA_PRAGMA.ID=:ID_Owner into :counterP;
    
    if (counterP=0 and counterH=0) then  exception NEVER_PARAMS_VALUES;--Ошибка во входном атрибуте - нет такого объекта среди изветсных 

    for
        select multiplexlnk.id_link, GET_PRAGMA_NAME_LIST.meaning ,EXTRAATTRIB_LNK.keyvalue,EXTRAATTRIB_LNK.ratio, multiplexlnk.id from EXTRAATTRIB_LNK
        inner join GET_PRAGMA_NAME_LIST on (GET_PRAGMA_NAME_LIST.id=EXTRAATTRIB_LNK.keyvalue)               --Соединяем с именем прагмы
        inner join multiplexlnk on (multiplexlnk.ID = EXTRAATTRIB_LNK.id_link)                              --только по совпадающим атрибутам с таблицей мультилинка
        where (EXTRAATTRIB_LNK.id_header=:id_ea_header and multiplexlnk.id_link=:ID_Owner)                  --для объекта, идентификатор которого передан в параметре
        into
            :id_link,
            :meaning,
            :keyvalue,
            :ratio,
            :id
    do
    begin
        suspend;
    end
end^


ALTER PROCEDURE GET_EA_LIST_NUM (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING FLOAT,
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
    begin
     FOR
        /*SELECT TEMPORALITY.ID_LINK, EXTRAATTRIB_SIM_NUM."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_NUM
            INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_NUM.ID_LINK = TEMPORALITY.ID)
            INNER JOIN VW_LAST_SIMPLVALUE ON (TEMPORALITY.ID_LINK = VW_LAST_SIMPLVALUE.ID_LINK) AND (TEMPORALITY.DATE_TIME = VW_LAST_SIMPLVALUE.LAST_DATE)
        WHERE 
          (
            (EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
          )*/
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_NUM."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_NUM
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_NUM.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_NUM.id_link,EXTRAATTRIB_SIM_NUM."VALUE"
        FROM EXTRAATTRIB_SIM_NUM
        WHERE 
          (
            (EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_RB (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
WHERE (id = :id_ea_header) into :is_temporality;
if(:is_temporality=1) then
begin
FOR
SELECT s.ID_LINK, r.MEANING, r.id_value 
FROM GET_EA_RB(:id_ea_header) r
INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = r.id_link)
INTO :id_link,
:MEANING,
:keyvalue
do
begin
SUSPEND;
end
end
else
begin
FOR
SELECT GET_EA_RB.id_link,GET_EA_RB.MEANING,GET_EA_RB.id_value
FROM GET_EA_RB(:id_ea_header)
INTO :id_link,
:MEANING,
:keyvalue
DO
BEGIN
SUSPEND;
END
end
end^


ALTER PROCEDURE GET_EA_LIST_SECUR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
begin
  FOR
    SELECT VW_USER_OBIECTS.ID_OBJECT, VW_USER_OBIECTS.MAX_OF_ACCESS_RIGHT
    FROM VW_USER_OBIECTS
    INTO :id_link,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
end^


ALTER PROCEDURE GET_EA_LIST_STR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
    begin
     FOR
        /*SELECT TEMPORALITY.ID_LINK, EXTRAATTRIB_SIM_STR."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_STR
            INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_STR.ID_LINK = TEMPORALITY.ID)
            INNER JOIN VW_LAST_SIMPLVALUE ON (TEMPORALITY.ID_LINK = VW_LAST_SIMPLVALUE.ID_LINK) AND (TEMPORALITY.DATE_TIME = VW_LAST_SIMPLVALUE.LAST_DATE)
        WHERE 
          (
            (EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
          )*/
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_STR."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_STR
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_STR.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_STR.id_link,EXTRAATTRIB_SIM_STR."VALUE"
        FROM EXTRAATTRIB_SIM_STR
        WHERE 
          (
            (EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_NEWFIELDNAME
RETURNS (
    FLDNAME VARCHAR(64))
AS
begin
  --БСА
  --Берем значение генератора, приводим к типу varchar(20) и конкатенируем с префиксом
  fldname='Fld'||cast(gen_id(gen_ea_fldnum,1) as varchar(20));
  while (
        exists(
            select fieldname from extraattrib_header where fieldname=:fldname))
  do
    fldname='Fld'||cast(gen_id(gen_ea_fldnum,1) as varchar(20));
  suspend;
end^


ALTER PROCEDURE GET_EA_RB (
    ID_EA INTEGER)
RETURNS (
    ID_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    ID_RB INTEGER,
    ID_VALUE INTEGER)
AS
BEGIN
FOR
SELECT EXTRAATRIB_RB.ID_HEADER, EXTRAATRIB_RB.ID_LINK, EXTRAATRIB_RB."VALUE", EXTRAATRIB_RB.ID_RB
FROM EXTRAATRIB_RB
where (EXTRAATRIB_RB.ID_HEADER=:id_ea)
INTO :ID_HEADER,
:ID_LINK,
:ID_VALUE,
:ID_RB
DO
BEGIN
select meaning from get_rb(:ID_VALUE,:id_rb) into :meaning;
SUSPEND;
END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_DATE (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING TIMESTAMP)
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, EXTRAATTRIB_SIM_DATE."VALUE"
                FROM EXTRAATTRIB_SIM_DATE
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_DATE.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_SIM_DATE.id_header=:id_header
    INTO    :id,
        :DATE_TIME,
        :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_DLL (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, extraattrib_dll."VALUE"
                FROM extraattrib_dll
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_DLL.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_DLL.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_INT (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING INTEGER)
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, EXTRAATTRIB_SIM_INT."VALUE"
                FROM EXTRAATTRIB_SIM_INT
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_INT.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link  and  EXTRAATTRIB_SIM_INT.id_header=:id_header
    INTO :ID, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_LNKH (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
declare variable hypotesisnameid integer;
BEGIN
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, get_ea_list_str.meaning, EXTRAATTRIB_LNK.ratio
                FROM EXTRAATTRIB_LNK
                left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_LNK.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_LNK.id_header=:id_header
    INTO :id,
         :DATE_TIME,
         :meaning,
         :ratio
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_LNKP (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
declare variable hypotesisnameid integer;
declare variable pragmadateid integer;
BEGIN
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('PragmaDate') into :PRAGMADATEID;

  FOR
    SELECT TEMPORALITY.id, TEMPORALITY.date_time,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning),
                EXTRAATTRIB_LNK.ratio
                FROM EXTRAATTRIB_LNK
                left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (EXTRAATTRIB_LNK.keyvalue=hypName.id_link)
                left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (EXTRAATTRIB_LNK.keyvalue=PragmaDate.id_link)
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_LNK.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_LNK.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning,
         :ratio
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_NUM (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING FLOAT)
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, extraattrib_sim_num."VALUE"
                FROM extraattrib_sim_num
                INNER JOIN TEMPORALITY ON (extraattrib_sim_num.id_link = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link  and  extraattrib_sim_num.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_RB (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id,TEMPORALITY.date_time, r.meaning
                FROM GET_EA_RB(:id_header) r
                INNER JOIN TEMPORALITY ON (r.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_STR (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id,TEMPORALITY.date_time, extraattrib_sim_str."VALUE"
                FROM extraattrib_sim_str
                INNER JOIN TEMPORALITY ON (extraattrib_sim_str.id_link = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link  and  extraattrib_sim_str.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EIDOS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
AS
begin
  /* Procedure Text */
  FOR
  select first 1  id, id_parent, name, species
  from VA_EIDOS
  where (id =:id_in)
  into :id, :id_parent, :name, :species
  do 
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_EIDOS_LIST (
    EIDOS_SPEC VARCHAR(64))
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255))
AS
begin
if(:eidos_spec='ALL' ) then
    begin
      FOR
      SELECT id, id_parent, name
      FROM VA_EIDOS
      order by LVL, id_parent, id  ascending
      INTO
        :id,:id_parent,:name
      do
      begin 
      suspend;
      end
    end
else
    begin
      FOR
      SELECT id, id_parent,name
      FROM VA_EIDOS
      WHERE species=:eidos_spec
      order by LVL, id_parent, id ascending
      INTO
        :id,:id_parent,:name
      do
      begin 
      suspend;
      end
    end
end^


ALTER PROCEDURE GET_EIDOSEXTRAATTRIB_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    NAMESTOREDPROC VARCHAR(64),
    TEMPORALLISTSPNAME VARCHAR(64),
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
AS
begin
    if (:id_eidos >0) then
    begin
      FOR
      select
        EXTRAATTRIB_HEADER.id,
        EXTRAATTRIB_HEADER.caption,
        EXTRAATTRIB_HEADER.fieldtype,
        EXTRAATTRIB_HEADER.id_belongfor,
        EXTRAATTRIB_HEADER.id_rb_describer,
        EXTRAATTRIB_HEADER.dll_filename,
        EXTRAATTRIB_HEADER.dll_procname,
        EXTRAATTRIB_HEADER.fieldname,
        EXTRAATTRIB_HEADER.temporality,
        EXTRAATTRIB_HEADER.required,
        EXTRAATTRIB_HEADER.visible,
        EXTRAATTRIB_HEADER.locked,
        extraattrib_support.namestoredproc,
        extraattrib_support.temporallistspname,
        EXTRAATTRIB_HEADER.multilnk,
        EXTRAATTRIB_HEADER.lnk_species,
        EXTRAATTRIB_HEADER.lnk_eidosid,
        EXTRAATTRIB_HEADER.lnk_hypid,
        EXTRAATTRIB_HEADER.lnk_needlist


      from EXTRAATTRIB_HEADER inner join extraattrib_support on  (EXTRAATTRIB_HEADER.fieldtype=extraattrib_support.fieldtype)
      where (EXTRAATTRIB_HEADER.id_CLASS =:id_EIDOS )
      into
        :id,
        :caption,
        :fieldtype,
        :id_belongfor,
        :id_rb_describer,
        :dll_filename,
        :dll_procname,
        :fieldname,
        :temporality,
        :required,
        :visible,
        :locked,
        :namestoredproc,
        :temporallistspname,
        :multilnk,
        :lnk_species,
        :lnk_eidosid,
        :lnk_hypid,
        :lnk_needlist
      do
      begin 
      suspend;
      end
    end
else
    begin
      FOR
      select
        EXTRAATTRIB_HEADER.id,
        EXTRAATTRIB_HEADER.caption,
        EXTRAATTRIB_HEADER.fieldtype,
        EXTRAATTRIB_HEADER.id_belongfor,
        EXTRAATTRIB_HEADER.id_rb_describer,
        EXTRAATTRIB_HEADER.dll_filename,
        EXTRAATTRIB_HEADER.dll_procname,
        EXTRAATTRIB_HEADER.fieldname,
        EXTRAATTRIB_HEADER.temporality,
        EXTRAATTRIB_HEADER.required,
        EXTRAATTRIB_HEADER.visible,
        EXTRAATTRIB_HEADER.locked,
        extraattrib_support.namestoredproc,
        extraattrib_support.temporallistspname,
        EXTRAATTRIB_HEADER.multilnk,
        EXTRAATTRIB_HEADER.lnk_species,
        EXTRAATTRIB_HEADER.lnk_eidosid,
        EXTRAATTRIB_HEADER.lnk_hypid,
        EXTRAATTRIB_HEADER.lnk_needlist

      from EXTRAATTRIB_HEADER inner join extraattrib_support on  (EXTRAATTRIB_HEADER.fieldtype=extraattrib_support.fieldtype)
      into
        :id,
        :caption,
        :fieldtype,
        :id_belongfor,
        :id_rb_describer,
        :dll_filename,
        :dll_procname,
        :fieldname,
        :temporality,
        :required,
        :visible,
        :locked,
        :namestoredproc,
        :temporallistspname,
        :multilnk,
        :lnk_species,
        :lnk_eidosid,
        :lnk_hypid,
        :lnk_needlist

      do
      begin 
      suspend;
      end
    end
end^


ALTER PROCEDURE GET_HYPOTESIS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER)
AS
begin
  /* Procedure Text */
  FOR
  select first 1  VA_HYPOTESIS.id ,VA_HYPOTESIS.id_eidos
  from VA_HYPOTESIS
  where (VA_HYPOTESIS.id =:id_in)
  into :id, :id_eidos
  do 
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_HYPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER)
AS
begin
  FOR
  SELECT
        VA_HYPOTESIS.ID
  FROM VA_HYPOTESIS
  WHERE VA_HYPOTESIS.id_EIDOS=:id_eidos
  INTO
    :id
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_HYPOTESIS_NAME_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
declare variable HYPOTESISNAMEID integer;
begin
     select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
  SELECT VA_HYPOTESIS.ID, hypName.meaning
    FROM VA_HYPOTESIS
      left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (VA_HYPOTESIS.id=hypName.id_link)
      WHERE VA_HYPOTESIS.id_EIDOS=:id_eidos
  INTO
    :id,:meaning
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_ID_TOPSPECIES (
    SPECIES VARCHAR(64))
RETURNS (
    ID_TOP_SPECIES INTEGER)
AS
begin
  select first 1 id from  VA_EIDOS
      where UPPER(species)=upper(:species) and id_parent<=1
  into :id_top_species;
  suspend;
end^


ALTER PROCEDURE GET_LINKED_HYPLIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
declare variable DT timestamp;
declare variable IS_TEMPORAL integer;
declare variable IS_MULTILINK integer;
declare variable KEYVALUE integer;
declare variable ID_LINK integer;
declare variable TEMP_ID_LINK integer;
declare variable TEMP_REALID_LINK integer;
BEGIN
  --Получаем значение программного времени с которым производится сравнение
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  --Извлекаем значения любой из ссылок на указанный объект--
  FOR
  select
        extraattrib_lnk.id_link,
        extraattrib_lnk.id_header,
        extraattrib_lnk.ratio
  from  extraattrib_lnk
  where extraattrib_lnk.keyvalue=:id_item
  into
    :id_link,
    :id_header,
    :ratio
  DO
      BEGIN
        select first 1 extraattrib_header.temporality,extraattrib_header.multilnk
          from extraattrib_header where extraattrib_header.id=:id_header
          into :is_temporal, :is_multilink;

        id_hypotesis=0;
        id_eidos=0;

        if (is_temporal=0 and is_multilink=0) then    --Значение - прямая одиночная ссылка
            begin
                select first 1 va_hypotesis.id,va_hypotesis.id_eidos
                    from va_hypotesis where va_hypotesis.id=:id_link into :id_hypotesis, :id_eidos;
            end
        else
            begin
            if (is_temporal<>0) then    --Значение темпоральное
                begin
                select first 1 temporality.id, temporality.id_link
                    from temporality
                    where temporality.id_header=:id_header and temporality.date_time<=:dt
                    order by temporality.date_time desc
                into :temp_id_link, :temp_realid_link;
                if(temp_id_link=id_link) then   --Значение текущего значения в темпоральной таблице соответствует
                    begin
                        select first 1 va_hypotesis.id,va_hypotesis.id_eidos
                            from va_hypotesis where va_hypotesis.id=:temp_realid_link into :id_hypotesis, :id_eidos;
                    end
                end
            if (is_multilink<>0) then    --Значение мультилинк
                begin
                    select first 1 multiplexlnk.id, multiplexlnk.id_link
                        from multiplexlnk
                        where multiplexlnk.id=:id_link
                        into :temp_id_link, :temp_realid_link;
                    select first 1 va_hypotesis.id,va_hypotesis.id_eidos
                        from va_hypotesis where va_hypotesis.id=:temp_realid_link into :id_hypotesis, :id_eidos;
                end
            end
        if (id_hypotesis>0 and id_eidos>0) then SUSPEND;
      END
END^


ALTER PROCEDURE GET_LINKED_PRAGMALIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_PRAGMA INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
declare variable DT timestamp;
declare variable IS_TEMPORAL integer;
declare variable IS_MULTILINK integer;
declare variable KEYVALUE integer;
declare variable ID_LINK integer;
declare variable TEMP_ID_LINK integer;
declare variable TEMP_REALID_LINK integer;
BEGIN
  --Получаем значение программного времени с которым производится сравнение
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  --Извлекаем значения любой из ссылок на указанный объект--
  FOR
  select
        extraattrib_lnk.id_link,
        extraattrib_lnk.id_header,
        extraattrib_lnk.ratio
  from  extraattrib_lnk
  where extraattrib_lnk.keyvalue=:id_item
  into
    :id_link,
    :id_header,
    :ratio
  DO
      BEGIN
        select first 1 extraattrib_header.temporality,extraattrib_header.multilnk
          from extraattrib_header where extraattrib_header.id=:id_header
          into :is_temporal, :is_multilink;

        id_pragma=0;
        id_eidos=0;

        if (is_temporal=0 and is_multilink=0) then    --Значение - прямая одиночная ссылка
            begin
                select first 1 va_pragma.id,va_pragma.id_eidos
                    from va_pragma where va_pragma.id=:id_link into :id_pragma, :id_eidos;
            end
        else
            begin
            if (is_temporal<>0) then    --Значение темпоральное
                begin
                select first 1 temporality.id, temporality.id_link
                    from temporality
                    where temporality.id_header=:id_header and temporality.date_time<=:dt and id=:id_link
                    order by temporality.date_time desc
                into :temp_id_link, :temp_realid_link;
                if(/*temp_id_link=id_link*/ 1=1) then   --Значение текущего значения в темпоральной таблице соответствует
                    begin
                        select first 1 va_pragma.id,va_pragma.id_eidos
                            from va_pragma where va_pragma.id=:temp_realid_link into :id_pragma, :id_eidos;
                    end
                end
            if (is_multilink<>0) then    --Значение мультилинк
                begin
                    select first 1 multiplexlnk.id, multiplexlnk.id_link
                        from multiplexlnk
                        where multiplexlnk.id=:id_link
                        into :temp_id_link, :temp_realid_link;
                    select first 1 va_pragma.id,va_pragma.id_eidos
                        from va_pragma where va_pragma.id=:temp_realid_link into :id_pragma, :id_eidos;
                end
            end
        if (id_pragma>0 and id_eidos>0) then SUSPEND;
      END
END^


ALTER PROCEDURE GET_MD5DLL (
    DLL_NAME VARCHAR(255))
RETURNS (
    MD5HASH VARCHAR(255))
AS
begin
  select first 1 dll_md5.md5sum from  DLL_MD5
      where dll_md5.dll_name=:dll_name
  into :md5hash;
  suspend;
end^


ALTER PROCEDURE GET_NUM_EIDOS_CHILDS (
    ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
begin
  select count(va_eidos.id_parent)
  from va_eidos
  where va_eidos.id_parent=:id
  into :result;
  suspend;
end^


ALTER PROCEDURE GET_PRAGMA (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
AS
begin
  /* Procedure Text */
  FOR
  select first 1  id, id_eidos, id_hypotesis
  from VA_PRAGMA
  where (id =:id_in)
  into :id, :id_eidos, :id_hypotesis
  do 
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_PRAGMA_LIST (
    ID_EIDOS INTEGER,
    ID_HYP_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER)
AS
begin
  FOR
  SELECT ID, id_hypotesis
    FROM va_pragma
    WHERE (ID_HYPOTESIS=:id_hyp_in AND id_eidos=:id_eidos)
  INTO
    :id, :id_hypotesis
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_PRAGMA_NAME_LIST
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    MEANING VARCHAR(255))
AS
declare variable PRAGMADATEID integer;
declare variable HYPOTESISNAMEID integer;
begin
   select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('PragmaDate') into :PRAGMADATEID;
     select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
  SELECT VA_PRAGMA.ID,VA_PRAGMA.id_hypotesis,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning)
    FROM va_pragma
      left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (va_pragma.id_hypotesis=hypName.id_link)
      left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (VA_PRAGMA.ID=PragmaDate.id_link)
   -- WHERE (PRAGMA.ID_HYPOTESIS=:id_hyp_in AND PRAGMA.id_eidos=:id_eidos)
  INTO
    :id, :id_hypotesis,:meaning
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_PRAGMA_WITH_HIPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    HYP_NAME VARCHAR(255))
AS
declare variable HYPOTESISNAMEID integer;
begin
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
  SELECT VA_PRAGMA.ID, VA_PRAGMA.id_hypotesis, get_ea_list_str.meaning
    FROM va_pragma left join get_ea_list_str(:HYPOTESISNAMEID) on (VA_PRAGMA.id_hypotesis=get_ea_list_str.id_link)
    WHERE VA_PRAGMA.id_eidos=:id_eidos
  INTO
    :id,:id_hypotesis,:hyp_name
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_RB (
    ID_VALUE INTEGER,
    ID_RB INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
DECLARE VARIABLE SQL VARCHAR(255);
begin
  select sqlstring from rb_describer where id=:id_rb into :sql;
  sql=sql||' where id='||cast(:id_value as varchar(24));
  for EXECUTE STATEMENT sql INTO :id, :meaning
  do
  suspend;
end^


ALTER PROCEDURE GET_REGED_DLLS
RETURNS (
    DLL_NAME VARCHAR(255),
    MD5_SUMM VARCHAR(255))
AS
BEGIN
    for
    select DLL_MD5.DLL_NAME, DLL_MD5.MD5SUM
    from DLL_MD5
    into :DLL_NAME, :MD5_SUMM
    do 
    begin
    suspend;
    end
END^


ALTER PROCEDURE SET_EA_ALTCAPTION (
    ID_EIDOS INTEGER,
    ID_HEADER INTEGER,
    NEWCAPTION VARCHAR(255))
AS
DECLARE VARIABLE countrecords integer; 
BEGIN
  select count(EXTRAATTRIB_ALTCAPTION.ID_HEADER) from EXTRAATTRIB_ALTCAPTION where EXTRAATTRIB_ALTCAPTION.ID_EIDOS=:ID_EIDOS and EXTRAATTRIB_ALTCAPTION.ID_HEADER=:ID_HEADER into countrecords;
  if(:countrecords>0) then
    begin
        update EXTRAATTRIB_ALTCAPTION set EXTRAATTRIB_ALTCAPTION.NEWCAPTION=:NEWCAPTION where EXTRAATTRIB_ALTCAPTION.ID_EIDOS=:ID_EIDOS and EXTRAATTRIB_ALTCAPTION.ID_HEADER=:ID_HEADER;
    end
  else
    begin
        insert into EXTRAATTRIB_ALTCAPTION (EXTRAATTRIB_ALTCAPTION.ID_EIDOS,EXTRAATTRIB_ALTCAPTION.ID_HEADER,EXTRAATTRIB_ALTCAPTION.NEWCAPTION) values (:ID_EIDOS,:ID_HEADER,:NEWCAPTION);
    end
END^


ALTER PROCEDURE SET_EA_DLL (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    KEYVALUE VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE IS_TEMPORALITY SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            id=GEN_ID(GEN_ID_ALL,1);   --получим идентификатор для id_link
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
           -- select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            --into :id_link;
            id_link=:id;                        --Здесь уже id_link
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_DLL
            (EXTRAATTRIB_DLL.id_header,EXTRAATTRIB_DLL.id_link, EXTRAATTRIB_DLL."VALUE", EXTRAATTRIB_DLL.keyvalue)
            values (:id_ea_header,:id_link,:meaning,:keyvalue);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение, найдем его линк
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            --и обновим
            update EXTRAATTRIB_DLL set EXTRAATTRIB_DLL."VALUE"=:meaning, EXTRAATTRIB_DLL.keyvalue=:keyvalue
            where EXTRAATTRIB_DLL.id_header=:id_ea_header and EXTRAATTRIB_DLL.id_link=:id_link;
        end
   end
  else
   begin
      /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_DLL.id_link) from EXTRAATTRIB_DLL
    where (EXTRAATTRIB_DLL.id_link=:id_link and EXTRAATTRIB_DLL.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_DLL
            (EXTRAATTRIB_DLL.id_header,EXTRAATTRIB_DLL.id_link, EXTRAATTRIB_DLL."VALUE", EXTRAATTRIB_DLL.keyvalue)
            values (:id_ea_header,:id_link,:meaning,:keyvalue);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_DLL set EXTRAATTRIB_DLL."VALUE"=:meaning, EXTRAATTRIB_DLL.keyvalue=:keyvalue
            where EXTRAATTRIB_DLL.id_header=:id_ea_header and EXTRAATTRIB_DLL.id_link=:id_link;
        end
   end
end^


ALTER PROCEDURE SET_EA_LNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
declare variable count_records smallint;
declare variable is_temporality smallint;
declare variable id integer;
declare variable kind_link integer;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY, EXTRAATTRIB_HEADER.fieldtype FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality,:kind_link;
  /*Определяем валидность переданной в параметре ссылке*/
  if(:kind_link=103) then --103 - ссылка на hipotesys
    begin
        select count(hypotesis.id) from hypotesis where hypotesis.id=:keyvalue into :count_records;
        if (:count_records<1) then  exception NEVER_PARAMS_VALUES;
    end
   else --104 - ссылка на pragma
    begin
        select count(pragma.id) from pragma where pragma.id=:keyvalue into :count_records;
        if (:count_records<1) then  exception NEVER_PARAMS_VALUES;
    end

  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            id=GEN_ID(GEN_ID_ALL,1);   --получим идентификатор для id_link
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
           -- select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            --into :id_link;
            id_link=:id;                        --Здесь уже id_link
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_LNK
            (EXTRAATTRIB_LNK.id_header,EXTRAATTRIB_LNK.id_link, EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio)
            values (:id_ea_header,:id_link,:keyvalue, :ratio);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение, найдем его линк
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            --и обновим
            update EXTRAATTRIB_LNK set EXTRAATTRIB_LNK.keyvalue=:keyvalue, EXTRAATTRIB_LNK.ratio=:ratio
            where EXTRAATTRIB_LNK.id_header=:id_ea_header and EXTRAATTRIB_LNK.id_link=:id_link;
        end
   end
  else
   begin
      /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_LNK.id_link) from EXTRAATTRIB_LNK
    where (EXTRAATTRIB_LNK.id_link=:id_link and EXTRAATTRIB_LNK.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_LNK
            (EXTRAATTRIB_LNK.id_header,EXTRAATTRIB_LNK.id_link, EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio)
            values (:id_ea_header,:id_link,:keyvalue, :ratio);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_LNK set EXTRAATTRIB_LNK.keyvalue=:keyvalue, EXTRAATTRIB_LNK.ratio=:ratio
            where EXTRAATTRIB_LNK.id_header=:id_ea_header and EXTRAATTRIB_LNK.id_link=:id_link;
        end
   end
end^


ALTER PROCEDURE SET_EA_MULTILNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_INLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
DECLARE VARIABLE ID INTEGER;
begin
  begin
  if(:id_inlist <= 0) then  /*Это новая запись, необходимо добавление*/
        begin
            id=GEN_ID(GEN_ID_ALL,1);   --получим идентификатор для id_link
            insert into MULTIPLEXLNK(id,id_link, id_header) values (:id,:id_link,:id_ea_header);
            insert into EXTRAATTRIB_LNK
            (EXTRAATTRIB_LNK.id_header,EXTRAATTRIB_LNK.id_link, EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio)
            values (:id_ea_header,:id,:keyvalue, :ratio);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим само значение, найдем его линк
            select id from MULTIPLEXLNK where MULTIPLEXLNK.id_link=:id_link and MULTIPLEXLNK.id=:id_inlist and MULTIPLEXLNK.id_header=:id_ea_header
            into :id;

            update EXTRAATTRIB_LNK set EXTRAATTRIB_LNK.keyvalue=:keyvalue, EXTRAATTRIB_LNK.ratio=:ratio
            where EXTRAATTRIB_LNK.id_header=:id_ea_header and EXTRAATTRIB_LNK.id_link=:id;
        end
   end
   id_out=id;
end^


ALTER PROCEDURE SET_EA_RB (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    ID_RB INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE COUNT_RECORDS INTEGER;
DECLARE VARIABLE IS_TEMPORALITY SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
if(:id_rb=0 and :meaning=0) then --удаление
    delete from extraatrib_rb where (extraatrib_rb.id_header=:id_ea_header and extraatrib_rb.id_link=:id_link);
else
 begin
   SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
   if(:is_temporality=1) then
    begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
      select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
      if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
             --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into extraatrib_rb
            (extraatrib_rb.id_header,extraatrib_rb.id_link, extraatrib_rb."VALUE", extraatrib_rb.id_rb)
            values (:id_ea_header,:id_link,:meaning,:id_rb);
        end
      else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update extraatrib_rb set extraatrib_rb."VALUE"=:meaning, extraatrib_rb.id_rb=:id_rb
            where extraatrib_rb.id_header=:id_ea_header and extraatrib_rb.id_link=:id_link;
        end
     end
    else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
      select count(extraatrib_rb.id_link) from extraatrib_rb
      where (extraatrib_rb.id_link=:id_link and extraatrib_rb.id_header=:id_ea_header)
      into :COUNT_RECORDS;
      if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin

            insert into extraatrib_rb
            (extraatrib_rb.id_header,extraatrib_rb.id_link, extraatrib_rb."VALUE", extraatrib_rb.id_rb)
            values (:id_ea_header,:id_link,:meaning,:id_rb);
        end
      else    /*Запись уже существует - обновление*/
        begin
            update extraatrib_rb set extraatrib_rb."VALUE"=:meaning, extraatrib_rb.id_rb=:id_rb
            where extraatrib_rb.id_header=:id_ea_header and extraatrib_rb.id_link=:id_link;
        end
    end
  end
end^


ALTER PROCEDURE SET_EA_SIMPLE_DATE (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING TIMESTAMP,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_DATE
            (EXTRAATTRIB_SIM_DATE.id_header,EXTRAATTRIB_SIM_DATE.id_link, EXTRAATTRIB_SIM_DATE."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_DATE set EXTRAATTRIB_SIM_DATE."VALUE"=:meaning
            where EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header and EXTRAATTRIB_SIM_DATE.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_DATE.id_link) from EXTRAATTRIB_SIM_DATE
    where (EXTRAATTRIB_SIM_DATE.id_link=:id_link and EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_DATE
            (EXTRAATTRIB_SIM_DATE.id_header,EXTRAATTRIB_SIM_DATE.id_link, EXTRAATTRIB_SIM_DATE."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_DATE set EXTRAATTRIB_SIM_DATE."VALUE"=:meaning
            where EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header and EXTRAATTRIB_SIM_DATE.id_link=:id_link;
        end
  end
end^


ALTER PROCEDURE SET_EA_SIMPLE_INT (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_INT
            (EXTRAATTRIB_SIM_INT.id_header,EXTRAATTRIB_SIM_INT.id_link, EXTRAATTRIB_SIM_INT."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_INT set EXTRAATTRIB_SIM_INT."VALUE"=:meaning
            where EXTRAATTRIB_SIM_INT.id_header=:id_ea_header and EXTRAATTRIB_SIM_INT.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_INT.id_link) from EXTRAATTRIB_SIM_INT
    where (EXTRAATTRIB_SIM_INT.id_link=:id_link and EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_INT
            (EXTRAATTRIB_SIM_INT.id_header,EXTRAATTRIB_SIM_INT.id_link, EXTRAATTRIB_SIM_INT."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_INT set EXTRAATTRIB_SIM_INT."VALUE"=:meaning
            where EXTRAATTRIB_SIM_INT.id_header=:id_ea_header and EXTRAATTRIB_SIM_INT.id_link=:id_link;
        end
  end
end^


ALTER PROCEDURE SET_EA_SIMPLE_NUM (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
DECLARE VARIABLE QUANTITY_ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id, id_link, date_time,ID_HEADER) values (:id, :id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_NUM
            (EXTRAATTRIB_SIM_NUM.id_header,EXTRAATTRIB_SIM_NUM.id_link, EXTRAATTRIB_SIM_NUM."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_NUM set EXTRAATTRIB_SIM_NUM."VALUE"=:meaning
            where EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header and EXTRAATTRIB_SIM_NUM.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_NUM.id_link) from EXTRAATTRIB_SIM_NUM
    where (EXTRAATTRIB_SIM_NUM.id_link=:id_link and EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_NUM
            (EXTRAATTRIB_SIM_NUM.id_header,EXTRAATTRIB_SIM_NUM.id_link, EXTRAATTRIB_SIM_NUM."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_NUM set EXTRAATTRIB_SIM_NUM."VALUE"=:meaning
            where EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header and EXTRAATTRIB_SIM_NUM.id_link=:id_link;
        end
  end
  /*Проверяем не является ли атрибут значением Quantity для ветки RES*/
  select ea_num_by_name.id_ea from ea_num_by_name('Quantity') into :quantity_id;
  if(:quantity_id=:id_ea_header) then execute procedure Calculate_Res_Remainder(:id_link);
end^


ALTER PROCEDURE SET_EA_SIMPLE_STR (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id, id_link, date_time,ID_HEADER) values (:id, :id_link,:date_of_change,:id_ea_header);
            id_link = :id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_STR
            (EXTRAATTRIB_SIM_STR.id_header,EXTRAATTRIB_SIM_STR.id_link, EXTRAATTRIB_SIM_STR."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_STR set EXTRAATTRIB_SIM_STR."VALUE"=:meaning
            where EXTRAATTRIB_SIM_STR.id_header=:id_ea_header and EXTRAATTRIB_SIM_STR.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_STR.id_link) from EXTRAATTRIB_SIM_STR
    where (EXTRAATTRIB_SIM_STR.id_link=:id_link and EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_STR
            (EXTRAATTRIB_SIM_STR.id_header,EXTRAATTRIB_SIM_STR.id_link, EXTRAATTRIB_SIM_STR."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_STR set EXTRAATTRIB_SIM_STR."VALUE"=:meaning
            where EXTRAATTRIB_SIM_STR.id_header=:id_ea_header and EXTRAATTRIB_SIM_STR.id_link=:id_link;
        end
  end
end^


ALTER PROCEDURE SET_EIDOS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:ID<1) then
        begin
            id_out=GEN_ID(GEN_ID_ALL,1);
            insert into EIDOS (eidos.id,EIDOS.id_parent ,EIDOS.name,EIDOS.species) values (:id_out,:id_parent ,:name,:species );
            --select id from EIDOS where (EIDOS.id_parent =:id_parent and EIDOS.name =:name and EIDOS.species=:species)  into :id_out ;
        end
    else
        begin
            update EIDOS set EIDOS.id_parent=:id_parent, EIDOS.name=:name, EIDOS.species=:species where id=:id ;
            --select id from EIDOS where EIDOS.id =:id   into :id_out ; --совершенно лишнее, id ведь не изменился
            id_out=:id;
        end
end^


ALTER PROCEDURE SET_EIDOSEXTRAATTRIB (
    ID INTEGER,
    ID_EIDOS INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:temporality=1 and :multilnk=1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, одновременно и многозначным и темпоральным он быть не может

    if (:ID<1) then
        begin
        id_out=GEN_ID(GEN_ID_ALL,1);
        insert into EXTRAATTRIB_HEADER
            (extraattrib_header.id,
            EXTRAATTRIB_HEADER.id_class,
            EXTRAATTRIB_HEADER.caption,
            EXTRAATTRIB_HEADER.fieldtype,
            EXTRAATTRIB_HEADER.id_belongfor,
            EXTRAATTRIB_HEADER.id_rb_describer,
            EXTRAATTRIB_HEADER.dll_filename,
            EXTRAATTRIB_HEADER.dll_procname,
            EXTRAATTRIB_HEADER.fieldname,
            EXTRAATTRIB_HEADER.temporality,
            EXTRAATTRIB_HEADER.required,
            EXTRAATTRIB_HEADER.visible,
            EXTRAATTRIB_HEADER.locked,
            EXTRAATTRIB_HEADER.multilnk,
            EXTRAATTRIB_HEADER.lnk_species,
            EXTRAATTRIB_HEADER.lnk_eidosid,
            EXTRAATTRIB_HEADER.lnk_hypid,
            EXTRAATTRIB_HEADER.lnk_needlist

            )
            values (:id_out,:id_EIDOS,:caption,:fieldtype,:id_belongfor,:id_rb_describer,:dll_filename,:dll_procname,:fieldname,:temporality,:required,
            :visible,:locked,:multilnk,:lnk_species,:lnk_eidosid,:lnk_hypid,:lnk_needlist);
            --select max(id) from EXTRAATTRIB_HEADER where (EXTRAATTRIB_HEADER.id_class=:id_eidos and EXTRAATTRIB_HEADER.caption=:caption and EXTRAATTRIB_HEADER.fieldtype=:fieldtype and EXTRAATTRIB_HEADER.id_belongfor=:id_belongfor) into :id_out;
            --последний запрос в корне неверный при многопользовательской работе
        end
    else
        begin
            update EXTRAATTRIB_HEADER set
                    EXTRAATTRIB_HEADER.id =:id,
                    EXTRAATTRIB_HEADER.id_class=:id_EIDOS,
                    EXTRAATTRIB_HEADER.caption=:caption,
                    EXTRAATTRIB_HEADER.fieldtype=:fieldtype,
                    EXTRAATTRIB_HEADER.id_belongfor=:id_belongfor,
                    EXTRAATTRIB_HEADER.id_rb_describer=:id_rb_describer,
                    EXTRAATTRIB_HEADER.dll_filename=:dll_filename,
                    EXTRAATTRIB_HEADER.dll_procname=:dll_procname,
                    EXTRAATTRIB_HEADER.fieldname=:fieldname,
                    EXTRAATTRIB_HEADER.temporality=:temporality,
                    EXTRAATTRIB_HEADER.required=:required,
                    EXTRAATTRIB_HEADER.visible=:visible,
                    EXTRAATTRIB_HEADER.locked=:locked,
                    EXTRAATTRIB_HEADER.multilnk=:multilnk,
                    EXTRAATTRIB_HEADER.lnk_species=:lnk_species,
                    EXTRAATTRIB_HEADER.lnk_eidosid=:lnk_eidosid,
                    EXTRAATTRIB_HEADER.lnk_hypid=:lnk_hypid,
                    EXTRAATTRIB_HEADER.lnk_needlist=:lnk_needlist

            where id=:id;
            --select id from EXTRAATTRIB_HEADER where EXTRAATTRIB_HEADER.id =:id   into :id_out ;
            id_out=:id;
        end
end^


ALTER PROCEDURE SET_HYPOTESIS (
    ID INTEGER,
    ID_EIDOS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:ID<1) then
        begin
            id_out=GEN_ID(GEN_ID_ALL,1);
            insert into HYPOTESIS (hypotesis.id,  HYPOTESIS.id_eidos ) values (:id_out, :id_eidos );
            --select max(HYPOTESIS.id) from HYPOTESIS where (HYPOTESIS.id_eidos =:id_eidos) into :id_out ;
        end
    else
        begin
            update HYPOTESIS set HYPOTESIS.id_eidos =:id_eidos where id=:id ;
            --select id from HYPOTESIS where HYPOTESIS.id =:id into :id_out ;
            id_out=:id;
        end
end^


ALTER PROCEDURE SET_LEVEL_INEIDOS
AS
declare variable id integer;
declare variable "LEV" integer;
declare variable id_parent integer;
begin
for
    select eidos.id,eidos.id_parent from eidos into :id, :id_parent
do
    begin
         if(:id_parent=0) then update eidos set eidos."LEVEL"=1 where eidos.id=:id;
         else
         begin
            lev=1;
            while (:id_parent>0) do
                begin
                    SELECT eidos.id_parent from eidos
                    where eidos.id=:id_parent into :id_parent;
                    lev=:lev+1;
                end
            update eidos set eidos."LEVEL"=:lev where eidos.id=:id;
        end
    end

end^


ALTER PROCEDURE SET_MD5DLL (
    DLL_NAME VARCHAR(255),
    MD5HASH VARCHAR(255))
AS
declare variable COUNT_RECORDS smallint;
begin
    select count(DLL_MD5.dll_name) from DLL_MD5 where DLL_MD5.dll_name=:dll_name into :count_records;
    if(:count_records<1) then
        begin
            insert into DLL_MD5(dll_name,md5sum) values (:dll_name,:md5hash);
        end
    else
        begin
            update DLL_MD5 set md5sum=:md5hash where DLL_MD5.dll_name=:dll_name;
        end
end^


ALTER PROCEDURE SET_PRAGMA (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:ID<1) then
        begin
            id_out=GEN_ID(GEN_ID_ALL,1);
            insert into PRAGMA (pragma.id, PRAGMA.id_eidos,PRAGMA.id_Hypotesis)
              values (:id_out, :id_eidos,:id_hypotesis);
            --select max(PRAGMA.id) from PRAGMA where (PRAGMA.id_eidos =:id_eidos and PRAGMA.id_hypotesis=:id_hypotesis) into :id_out ;
        end
    else
        begin
            update PRAGMA set PRAGMA.id_eidos=:id_eidos,PRAGMA.id_hypotesis=:id_hypotesis where id=:id ;
            --select id from PRAGMA where PRAGMA.id =:id into :id_out ;
            id_out=:id;
        end
end^


ALTER PROCEDURE SP_GET_FOREIGN_KEY
RETURNS (
    PK VARCHAR(31),
    TABLENAME VARCHAR(31),
    FIELDNAMEPK VARCHAR(31),
    FK VARCHAR(31),
    TABLENAMESOURCE VARCHAR(31),
    FIELDNAMEFK VARCHAR(31))
AS
BEGIN
  FOR
    SELECT RDB$INDICES.RDB$INDEX_NAME PK, RDB$INDICES.RDB$RELATION_NAME TableName, RDB$INDEX_SEGMENTS.RDB$FIELD_NAME FieldNamePK,
           RDB$INDICES1.RDB$INDEX_NAME FK, RDB$INDICES1.RDB$RELATION_NAME TableNameSource, RDB$INDEX_SEGMENTS1.RDB$FIELD_NAME FieldNameFK
    FROM RDB$INDEX_SEGMENTS RDB$INDEX_SEGMENTS1
       INNER JOIN RDB$INDICES RDB$INDICES1 ON (RDB$INDEX_SEGMENTS1.RDB$INDEX_NAME = RDB$INDICES1.RDB$INDEX_NAME)
       INNER JOIN RDB$INDICES ON (RDB$INDICES1.RDB$FOREIGN_KEY = RDB$INDICES.RDB$INDEX_NAME)
       INNER JOIN RDB$INDEX_SEGMENTS ON (RDB$INDICES.RDB$INDEX_NAME = RDB$INDEX_SEGMENTS.RDB$INDEX_NAME)
    INTO :PK,
         :TABLENAME,
         :FIELDNAMEPK,
         :FK,
         :TABLENAMESOURCE,
         :FIELDNAMEFK
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_RB_FIELDS (
    RB_TABLENAME VARCHAR(31))
RETURNS (
    RDB$RELATION_NAME VARCHAR(31),
    RDB$FIELD_NAME VARCHAR(31),
    RDB$DESCRIPTION BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    RDB$FIELD_TYPE SMALLINT,
    RDB$TYPE_NAME VARCHAR(31),
    RDB$FIELD_LENGTH SMALLINT,
    RDB$FIELD_POSITION SMALLINT,
    RDB$FIELD_SCALE SMALLINT,
    RDB$FIELD_SUB_TYPE SMALLINT,
    RDB$FIELD_PRECISION SMALLINT,
    RDB$SEGMENT_LENGTH SMALLINT,
    RDB$NULL_FLAG SMALLINT,
    RDB$CONSTRAINT_NAME VARCHAR(31),
    RDB$CONSTRAINT_TYPE VARCHAR(11))
AS
BEGIN
  FOR
    SELECT VW_FIELDS.RDB$RELATION_NAME, VW_FIELDS.RDB$FIELD_NAME, VW_FIELDS.RDB$DESCRIPTION, VW_FIELDS.RDB$FIELD_TYPE,
    VW_FIELDS.RDB$TYPE_NAME, VW_FIELDS.RDB$FIELD_LENGTH, VW_FIELDS.RDB$FIELD_POSITION,
    VW_FIELDS.RDB$FIELD_SCALE, VW_FIELDS.RDB$FIELD_SUB_TYPE, VW_FIELDS.RDB$FIELD_PRECISION, VW_FIELDS.RDB$SEGMENT_LENGTH,VW_FIELDS.RDB$NULL_FLAG,
    VW_CONSTRAINTS.RDB$CONSTRAINT_NAME, VW_CONSTRAINTS.RDB$CONSTRAINT_TYPE
    FROM VW_FIELDS
       LEFT OUTER JOIN VW_CONSTRAINTS ON (VW_FIELDS.RDB$RELATION_NAME = VW_CONSTRAINTS.RDB$RELATION_NAME) AND (VW_FIELDS.RDB$FIELD_NAME = VW_CONSTRAINTS.RDB$FIELD_NAME)
       --INNER JOIN RB_DESCRIBER ON (VW_FIELDS.RDB$RELATION_NAME = RB_DESCRIBER.RB_TABLENAME)
    where VW_FIELDS.RDB$RELATION_NAME=:RB_TABLENAME
    INTO :RDB$RELATION_NAME,
         :RDB$FIELD_NAME,
         :RDB$DESCRIPTION,
         :RDB$FIELD_TYPE,
         :RDB$TYPE_NAME,
         :RDB$FIELD_LENGTH,
         :RDB$FIELD_POSITION,
         :RDB$FIELD_SCALE,
         :RDB$FIELD_SUB_TYPE,
         :RDB$FIELD_PRECISION,
         :RDB$SEGMENT_LENGTH,
         :RDB$NULL_FLAG,
         :RDB$CONSTRAINT_NAME,
         :RDB$CONSTRAINT_TYPE
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_RIGHTS_FOR_OBJECT (
    ID_OBJ INTEGER)
RETURNS (
    GROUP_NAME VARCHAR(255),
    RIGHT_NAME VARCHAR(64))
AS
BEGIN
  FOR
    SELECT GROUPS.NAME GROUP_NAME, ACCESS_RIGHT.NAME RIGHT_NAME
    FROM ACL
       INNER JOIN GROUPS ON (ACL.GID = GROUPS.ID)
       INNER JOIN ACCESS_RIGHT ON (ACL.ACCESS_RIGHT = ACCESS_RIGHT.ID)
       where  ACL.ID_OBJECT=:id_obj
    INTO :GROUP_NAME,
         :RIGHT_NAME
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_TEMPORALY_VALUE (
    ID_HEADER INTEGER)
RETURNS (
    ID_LINK INTEGER,
    ID INTEGER)
AS
DECLARE VARIABLE DT TIMESTAMP;
BEGIN
  select var_dt.dt from var_dt
  where var_dt.user_name=user into :dt;
  for
    SELECT DISTINCT TEMPORALITY.ID_LINK
    FROM TEMPORALITY
    WHERE 
    (
      (TEMPORALITY.ID_HEADER = :ID_HEADER)
    )
    into :id_link
 do
  begin
   SELECT first 1 TEMPORALITY.ID
   FROM TEMPORALITY
   where ((TEMPORALITY.ID_HEADER = :ID_HEADER) and (temporality.id_link=:id_link) and (TEMPORALITY.date_time<=:dt) )
    order by TEMPORALITY.DATE_TIME desc
   INTO :ID;
    SUSPEND;
  end

END^


ALTER PROCEDURE SP_GET_TYPE
RETURNS (
    ID SMALLINT,
    FIELD_TYPE SMALLINT,
    FIELD_TYPE_NAME VARCHAR(31),
    TYPE_NAME VARCHAR(62),
    FIELD_LENGTH SMALLINT,
    FIELD_SCALE SMALLINT,
    FIELD_SUB_TYPE SMALLINT,
    FIELD_PRECISION SMALLINT,
    SEGMENT_LENGTH SMALLINT,
    CAPTION VARCHAR(62))
AS
BEGIN
  FOR
    SELECT FIELDS_TYPE.ID, FIELDS_TYPE.FIELD_TYPE, FIELDS_TYPE.FIELD_TYPE_NAME, FIELDS_TYPE.TYPE_NAME, FIELDS_TYPE.FIELD_LENGTH, FIELDS_TYPE.FIELD_SCALE, FIELDS_TYPE.FIELD_SUB_TYPE, FIELDS_TYPE.FIELD_PRECISION, FIELDS_TYPE.SEGMENT_LENGTH, FIELDS_TYPE.CAPTION
    FROM FIELDS_TYPE
    INTO :ID,
         :FIELD_TYPE,
         :FIELD_TYPE_NAME,
         :TYPE_NAME,
         :FIELD_LENGTH,
         :FIELD_SCALE,
         :FIELD_SUB_TYPE,
         :FIELD_PRECISION,
         :SEGMENT_LENGTH,
         :CAPTION
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_USER_OBJ (
    TYPE_OBJ SMALLINT)
RETURNS (
    ID INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  FOR
    SELECT ID_OBJ.ID, MAX( ACL.ACCESS_RIGHT ) MAX_OF_ACCESS_RIGHT
    FROM ACL
       INNER JOIN ID_OBJ ON (ACL.ID_OBJECT = ID_OBJ.ID)
       INNER JOIN MEMBERSHIP ON (ACL.GID = MEMBERSHIP.GID)
    WHERE 
       (
          (MEMBERSHIP.USER_NAME = user)
       and 
          (ID_OBJ.TYPE_OBJ = :type_obj)
       )
    GROUP BY ID_OBJ.ID
    INTO :ID,
         :MAX_OF_ACCESS_RIGHT
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_USER_OBJECTS
RETURNS (
    ID_OBJECT INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  FOR
    SELECT VW_USER_OBIECTS1.ID_OBJECT, VW_USER_OBIECTS1.MAX_OF_ACCESS_RIGHT
    FROM VW_USER_OBIECTS
       INNER JOIN EXTRAATRIB_RB ON (EXTRAATRIB_RB."VALUE" = VW_USER_OBIECTS.ID_OBJECT )
       INNER JOIN EXTRAATTRIB_HEADER ON (EXTRAATRIB_RB.ID_HEADER = EXTRAATTRIB_HEADER.ID)
       INNER JOIN VW_USER_OBIECTS VW_USER_OBIECTS1 ON (EXTRAATRIB_RB.ID_LINK = VW_USER_OBIECTS1.ID_OBJECT)
    WHERE 
       (
          (EXTRAATTRIB_HEADER.FIELDNAME = 'PrBelongTo')
       )
    INTO :ID_OBJECT,
         :MAX_OF_ACCESS_RIGHT
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_USER_PRAGMA
RETURNS (
    MAX_OF_ACCESS_RIGHT INTEGER,
    ID INTEGER)
AS
DECLARE VARIABLE ID_HEADER INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.id
  from EXTRAATTRIB_HEADER
  WHERE 
       (
          (EXTRAATTRIB_HEADER.FIELDNAME = 'PrBelongTo')
       )
  into :id_header;
  for
   SELECT ACL.ID_OBJECT, max(ACL.ACCESS_RIGHT)
    FROM ACL
        INNER JOIN EXTRAATRIB_RB ON (ACL.ID_OBJECT = EXTRAATRIB_RB.id_link)
        INNER JOIN MEMBERSHIP ON (ACL.GID = MEMBERSHIP.GID)
    WHERE 
    (
      (MEMBERSHIP.USER_NAME = user) and (EXTRAATRIB_RB.id_header=:id_header)
    )
    GROUP BY ACL.ID_OBJECT
   into  :id,
         :MAX_OF_ACCESS_RIGHT
   DO
  BEGIN
    SUSPEND;
  END

end^


ALTER PROCEDURE SP_GET_VAR_DT
RETURNS (
    DT TIMESTAMP)
AS
BEGIN
  FOR
    SELECT VAR_DT.DT
    FROM VAR_DT
    WHERE 
       (
          (VAR_DT.USER_NAME = user)
       )
    INTO :DT
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_CURRENT_USER
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  FOR
    SELECT USERS.UID, USERS.NAME, USERS.ID_TYPE_ACCES_RIGHT, USERS.FULL_NAME, USERS.DESCRIPTIONS, USERS.IS_DELETED, USERS.IS_DISABLED
    FROM USERS
    where (USERS.NAME=user)
    INTO :UID,
         :NAME,
         :ID_TYPE_ACCES_RIGHT,
         :FULL_NAME,
         :DESCRIPTIONS,
         :IS_DELETED,
         :IS_DISABLED
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC (
    OBJ VARCHAR(512),
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
    --check user

    if (:uid=-1) then
        select uid from users where name=user into  :uid;

  FOR
   SELECT ETC.ID, ETC.OBJECT, ETC.ID_USER, USERS.NAME
   FROM USERS
   RIGHT OUTER JOIN ETC ON (USERS.UID = ETC.ID_USER)
   where etc.id_user=:uid and etc.object=:obj
    INTO :ID,
         :OBJECT,
         :ID_USER,
         :user_name
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_ALL (
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN

    if (:uid<>-1) then
        select uid from users where name=user into  :uid;

  FOR
   SELECT ETC.ID, ETC.OBJECT, ETC.ID_USER, USERS.NAME
   FROM USERS
   RIGHT OUTER JOIN ETC ON (USERS.UID = ETC.ID_USER)
   where etc.id_user=:uid
    INTO :ID,
         :OBJECT,
         :ID_USER,
         :user_name
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_ALL2USER (
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
declare variable uid integer;
BEGIN


        select uid from users where name=:uname into  :uid;

  FOR
   SELECT ETC.ID, ETC.OBJECT, ETC.ID_USER, USERS.NAME
   FROM USERS
   RIGHT OUTER JOIN ETC ON (USERS.UID = ETC.ID_USER)
   where etc.id_user=:uid
    INTO :ID,
         :OBJECT,
         :ID_USER,
         :user_name
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_PARAMETERS (
    OBJECT_ID INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  FOR
    select etc_parameters.id, etc_parameters.name, etc_parameters.param_type, etc_parameters.id_object, etc_parameters.date_value, etc_parameters.float_value, etc_parameters.int_value, etc_parameters.string_value, etc_parameters.blob_value
    from etc_parameters
    where etc_parameters.id_object=:object_id
    INTO :ID,
         :NAME,
         :PARAM_TYPE,
         :ID_OBJECT,
         :DATE_VALUE,
         :FLOAT_VALUE,
         :INT_VALUE,
         :STRING_VALUE,
         :BLOB_VALUE
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_PARAMETERS2USER (
    OBJECT VARCHAR(512),
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE SMALLINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  FOR
    select etc_parameters.id, etc_parameters.name, etc_parameters.param_type, etc_parameters.id_object, etc_parameters.date_value, etc_parameters.float_value, etc_parameters.int_value, etc_parameters.string_value, etc_parameters.blob_value
        from users
            inner join etc on (users.uid = etc.id_user)
            inner join etc_parameters on (etc.id = etc_parameters.id_object)
        where 
         (
          (etc.object = :object)
           and 
          (users.name = :uname)
         )
    INTO :ID,
         :NAME,
         :PARAM_TYPE,
         :ID_OBJECT,
         :DATE_VALUE,
         :FLOAT_VALUE,
         :INT_VALUE,
         :STRING_VALUE,
         :BLOB_VALUE
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_FLOATS (
    PARAM_LINKS INTEGER)
RETURNS (
    ID INTEGER,
    "VALUE" DOUBLE PRECISION,
    LINKS INTEGER)
AS
BEGIN
  EXIT;
END^


ALTER PROCEDURE SP_READ_RB_DESCRIBER
RETURNS (
    ID INTEGER,
    RB_NAME VARCHAR(255),
    RB_TABLENAME VARCHAR(64),
    IS_RB_IERARCHY SMALLINT)
AS
BEGIN
  FOR
    SELECT RB_DESCRIBER.ID, RB_DESCRIBER.RB_NAME, RB_DESCRIBER.RB_TABLENAME, RB_DESCRIBER.IS_RB_IERARCHY
    FROM RB_DESCRIBER
    INTO :ID,
         :RB_NAME,
         :RB_TABLENAME,
         :IS_RB_IERARCHY
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_USER_INFO
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  FOR
    SELECT USERS.UID, USERS.NAME, USERS.ID_TYPE_ACCES_RIGHT, USERS.FULL_NAME, USERS.DESCRIPTIONS, USERS.IS_DELETED, USERS.IS_DISABLED
    FROM USERS where USERS.NAME=user
    INTO :UID,
         :NAME,
         :ID_TYPE_ACCES_RIGHT,
         :FULL_NAME,
         :DESCRIPTIONS,
         :IS_DELETED,
         :IS_DISABLED
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_SET_ETC (
    ID INTEGER,
    OBJECT VARCHAR(512),
    ID_USER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
begin
  if (:id_user=-1) then SELECT USERS.UID FROM USERS where (USERS.NAME=user) INTO :id_user;
  if (:id < 1) then
        begin
           if(not(exists(select * from etc where etc.object=:object and etc.id_user=:id_user)))
            then
             begin
                result=gen_id(gen_etc,1);
                insert into ETC (id, object, ID_USER) values (:result, :object,:id_user);
             end
           else result=-1;
        end
      else
        if (:object ='') then
           begin
            delete from etc where id=:id;
            result=0;
           end
        else
            begin
             if((exists(select * from etc where etc.id=:id)))
               then
                if(not(exists(select * from etc where etc.object=:object and etc.id_user=:id_user))) then
                 begin
                   update etc set object=:object, id_user=:id_user where id=:id;
                   result=:id;
                 end
             else result=-1;
            end
end^


ALTER PROCEDURE SP_SET_ETC2OBJ (
    UNAME VARCHAR(64),
    OLD_OBJECT VARCHAR(512),
    NEW_OBJECT VARCHAR(512))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE SP_SET_PARAMETERS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 4096)
RETURNS (
    RESULT INTEGER)
AS
declare variable old_name varchar(255);
declare variable old_id integer;
declare variable old_id_object integer;
declare variable old_param_type smallint;
begin
    if (:id < 1) then
        begin
           result=gen_id(gen_etc,1);
           insert into etc_parameters(id, name,param_type,id_object,date_value,float_value,int_value,string_value,blob_value)
            values(:result,:name,:param_type,:id_object,:date_value,:float_value,:int_value,:string_value,:blob_value);
        end
    else
        if (:name ='') then
           begin
            delete from etc_parameters where id=:id;
            result=0;
           end
        else
           begin
             update etc_parameters set name=:name, param_type=:param_type, id_object=:id_object, date_value=:date_value,
              float_value=:float_value, int_value=:int_value,string_value=:string_value,blob_value=:blob_value
             where id=:id;
             result=:id;
            end
end^


ALTER PROCEDURE SP_SET_RENAME_PARAMETER (
    ID INTEGER,
    NEW_NAME VARCHAR(250))
AS
begin
update etc_parameters set etc_parameters.name=:new_name where id=:id;
end^


ALTER PROCEDURE SP_SET_RIGHT (
    GID INTEGER,
    OID INTEGER,
    RID INTEGER,
    MODE SMALLINT)
AS
DECLARE VARIABLE ID INTEGER;
begin
--для конкреного объекта
    select first 1 id from ACL
    where gid=:gid and id_object=:oid into :id;
    if (not :id is null) then
          --update rigth
          update acl set access_right=:rid where id=:id;
    else
          insert into acl(gid,access_right,id_object) values(:gid,:rid,:oid);

if(:mode=1) then --и для дочерних?
--рекурсивно для всех дочерних объектов
    begin
        FOR
            SELECT id from id_obj 
                where id_parent=:oid into :id
        do
        begin
            EXECUTE PROCEDURE SP_SET_RIGHT(:gid,:id,:rid,:mode);
        end
    end
end^


ALTER PROCEDURE SP_SET_VAR_DT (
    DT TIMESTAMP)
AS
begin
if (exists(select user_name from var_dt where user_name=user)) then
    update var_dt set dt=:dt where user_name=user;
else
    insert into var_dt(user_name,dt) values(user,:dt);
end^


ALTER PROCEDURE VA_EIDOS
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64),
    LVL SMALLINT)
AS
declare variable DT timestamp;
begin
  /* Процедура выводит содержимое таблицы EIDOS без отмеченных к удалению записей */
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  for
  select
    eidos.id,
    eidos.id_parent,
    eidos.name,
    eidos.species,
    eidos."LEVEL"
  from eidos
  where
    eidos.date_delete>:dt or eidos.date_delete is NULL
  into
    :id,
    :id_parent,
    :name,
    :species,
    :lvl
  do
  begin
  suspend;
  end
end^


ALTER PROCEDURE VA_HYPOTESIS
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER)
AS
declare variable DT timestamp;
begin
  /* Процедура выводит содержимое таблицы HYPOTESIS без отмеченных к удалению записей */
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  for
  select
    HYPOTESIS.id,
    HYPOTESIS.id_eidos
  from HYPOTESIS inner join VA_EIDOS on (HYPOTESIS.ID_EIDOS=VA_EIDOS.ID)
  where
    HYPOTESIS.date_delete>:dt or HYPOTESIS.date_delete is NULL
  into
    :id,
    :id_eidos
  do
  begin
  suspend;
  end
end^


ALTER PROCEDURE VA_PRAGMA
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
AS
declare variable DT timestamp;
begin
  /* Процедура выводит содержимое таблицы PRAGMA без отмеченных к удалению записей */
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  for
  select
    PRAGMA.id,
    PRAGMA.id_eidos,
    PRAGMA.id_hypotesis
  from PRAGMA inner join VA_EIDOS on (PRAGMA.ID_EIDOS=VA_EIDOS.ID) inner join VA_HYPOTESIS on (PRAGMA.ID_HYPOTESIS=VA_HYPOTESIS.ID)
  where
    PRAGMA.date_delete>:dt or PRAGMA.date_delete is NULL
  into
    :id,
    :id_eidos,
    :id_hypotesis
  do
  begin
  suspend;
  end
end^



SET TERM ; ^



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE ACCESS_RIGHT
'Описание прав доступа';

DESCRIBE TABLE ACL
'Список прав доступа';

DESCRIBE TABLE EXTRAATTRIB_ALTCAPTION
'Таблица хранит заголовки полей которые требуется заменить в оригинальной модели';

DESCRIBE TABLE GROUPS
'Таблица групп пользователей';

DESCRIBE TABLE IRB_STRUCTURES
'Таблица - справочник структурных подразделений/организаций';

DESCRIBE TABLE IRB_UNITMESUREMENT
'Справочник единиц измерения. Пример:
    Единицы объема
        м3
        дм3
        литр
    Единицы массы
        кг
        т
        гр';

DESCRIBE TABLE MEMBERSHIP
'Таблица членства пользователей в группе';

DESCRIBE TABLE TEMPORALITY
'Таблица служит для создания темпоральных структур полей';

DESCRIBE TABLE USERS
' РўР°Р±Р»РёС†Р° РїРѕР»СЊР·РѕРІР°С‚РµР»РµР№';

DESCRIBE TABLE VAR_DT
'Таблица переменной пользователя - состояние на дату';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE GET_EA_LIST_INT
'   Процедура возвращает список дополнительных атрибутов целого типа для экстраатрибута,
чей идентификатор передан в параметре. Вместе со значением возвращается идентификатор ссылки на объект';

DESCRIBE PROCEDURE GET_EA_LIST_RB
'Процедура возвращает список дополнительных атрибутов справочного типа для экстраатрибута,
чей идентификатор передан в параметре. Вместе со значением возвращается идентификатор ссылки на объект';

DESCRIBE PROCEDURE GET_EA_LIST_SECUR
'Возвращает список объектов с правами доступа к ним';

DESCRIBE PROCEDURE GET_EA_LIST_STR
'Процедура возвращает список дополнительных атрибутов строкового типа для экстраатрибута,
чей идентификатор передан в параметре. Вместе со значением возвращается идентификатор ссылки на объект';

DESCRIBE PROCEDURE GET_EA_NEWFIELDNAME
'Процедура создает имя поля для вновь создаваемых экстраатрибутов, при этом генерируется имя основанное на генераторе
для уникальности и конкатенируется с FLD префиксом, кое значение и возвращается в виде параметра';

DESCRIBE PROCEDURE SET_EA_RB
'Процедура меняет значение справочного экстраатрибута.';

DESCRIBE PROCEDURE SET_EA_SIMPLE_INT
'Процедура заносит значение экстраатрибута типа целых чисел';

DESCRIBE PROCEDURE SET_PRAGMA
'Запишем объект';

DESCRIBE PROCEDURE SP_GET_RB_FIELDS
'Возвращаем метаданные по имени таблицы';

DESCRIBE PROCEDURE SP_GET_RIGHTS_FOR_OBJECT
'Процедура возвращает список групп с правом доступа к данному объекту по его id';

DESCRIBE PROCEDURE SP_GET_TYPE
'Процедура возвращает типы данных';

DESCRIBE PROCEDURE SP_SET_RIGHT
'Изменение режима доступа к объекту для группы';

DESCRIBE PROCEDURE SP_SET_VAR_DT
'Устанавливаем пользовательское время состояния системы';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TRIGGER ID_OBJ_BD0
'Удаляем значения при удалении в мастер таблице';

DESCRIBE TRIGGER ID_OBJ_BI0
'Проверяем наличие значения в мастер-таблицах';

DESCRIBE TRIGGER TRG_USERS_BI0
'Генерация уникального id - автоинкремент';



/******************************************************************************/
/***                          Fields descriptions                           ***/
/******************************************************************************/

DESCRIBE FIELD AO TABLE ACCESS_RIGHT
'Admin option';

DESCRIBE FIELD A TABLE ACCESS_RIGHT
'Append';

DESCRIBE FIELD W TABLE ACCESS_RIGHT
'Write';

DESCRIBE FIELD D TABLE ACCESS_RIGHT
'Delete - право на удаление объекта';

DESCRIBE FIELD R TABLE ACCESS_RIGHT
'Read';

DESCRIBE FIELD GID TABLE ACL
'Идентификатор группы пользователей';

DESCRIBE FIELD ACCESS_RIGHT TABLE ACL
'Право доступа';

DESCRIBE FIELD ID_OBJECT TABLE ACL
'На объект';

DESCRIBE FIELD NAME TABLE GROUPS
'Название группы';

DESCRIBE FIELD ID TABLE ID_OBJ
'Идентификатор объекта';

DESCRIBE FIELD TYPE_OBJ TABLE ID_OBJ
'Тип объекта: 0 - Eidos, 1 - Hypotesis, 2 - Pragma';

DESCRIBE FIELD ID_PARENT TABLE ID_OBJ
'Для отображения иерархии при присвоении прав';

DESCRIBE FIELD FIRSTNAME TABLE IRB_HUMANS
'Имя';

DESCRIBE FIELD MIDDLENAME TABLE IRB_HUMANS
'Отчество';

DESCRIBE FIELD LASTNAME TABLE IRB_HUMANS
'Фамилия';

DESCRIBE FIELD LNK_ORGANIZATION TABLE IRB_HUMANS
'Ссылка на организацию';

DESCRIBE FIELD JOB_NAME TABLE IRB_HUMANS
'Должность';

DESCRIBE FIELD NAME TABLE IRB_OPERATIONS
'Имя операции';

DESCRIBE FIELD ID_PARENT TABLE IRB_PLACESUSE
'Ссылка народителя';

DESCRIBE FIELD NAME TABLE IRB_PLACESUSE
'Название места установки';

DESCRIBE FIELD ID_PARENT TABLE IRB_RESOURCES
'Ссылка на родителя';

DESCRIBE FIELD NAME TABLE IRB_RESOURCES
'Наименование ресурса';

DESCRIBE FIELD LNK_UNITMESUR TABLE IRB_RESOURCES
'Ссылка на справочник единиц измерения';

DESCRIBE FIELD ID_PARENT TABLE IRB_STRUCTURES
'Ссылка на родителя';

DESCRIBE FIELD NAME TABLE IRB_STRUCTURES
'Наименование организации';

DESCRIBE FIELD INN TABLE IRB_STRUCTURES
'ИНН';

DESCRIBE FIELD LNK_HUMANS_CHIEF TABLE IRB_STRUCTURES
'Ссылка на справочник персон - начальника организации';

DESCRIBE FIELD ID_PARENT TABLE IRB_UNITMESUREMENT
'Ссылка на родителя';

DESCRIBE FIELD NAME TABLE IRB_UNITMESUREMENT
'Имя единицы измерения';

DESCRIBE FIELD GID TABLE MEMBERSHIP
'Идентификатор группы';

DESCRIBE FIELD USER_NAME TABLE MEMBERSHIP
'Пользователь';

DESCRIBE FIELD RB_NAME TABLE RB_DESCRIBER
' Имя справочника';

DESCRIBE FIELD RB_TABLENAME TABLE RB_DESCRIBER
'Имя таблицы справочника';

DESCRIBE FIELD IS_RB_IERARCHY TABLE RB_DESCRIBER
'Признак иерархического справочника';

DESCRIBE FIELD ID TABLE TEMPORALITY
' Является ли комбинация id,id_link уникальной?';

DESCRIBE FIELD ID_HEADER TABLE TEMPORALITY
'Идентификатор атрибута';

