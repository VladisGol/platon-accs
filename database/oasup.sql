/*
software core of accounting system "Platon".
Copyright (C) 2005-2009 Borisenkov S., Golovyrin V.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation version 2.1 of the License.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Contacts: e-mail vladisgol@rambler.ru

Ядро системы учета "Платон".
Авторами программы являются Борисенков Сергей Александрович и Головырин Владислав Владимирович, 2005-2009г.
Данная библиотека является свободным программным обеспечением. Вы вправе распространять ее и/или модифицировать
в соответствии с условиями версии 2.1 Стандартной Общественной Лицензии Ограниченного Применения GNU,
опубликованной Free Software Foundation.
Мы распространяем эту программу в надежде на то, что она будет вам полезной,
однако НЕ ПРЕДОСТАВЛЯЕМ НА НЕЕ НИКАКИХ ГАРАНТИЙ, в том числе ГАРАНТИИ ТОВАРНОГО СОСТОЯНИЯ ПРИ ПРОДАЖЕ и
ПРИГОДНОСТИ ДЛЯ ИСПОЛЬЗОВАНИЯ В КОНКРЕТНЫХ ЦЕЛЯХ.
Для получения более подробной информации ознакомьтесь со Стандартной Общественной Лицензией Ограниченного
Применений GNU.
Связаться с авторами программы вы можете по e-mail vladisgol@rambler.ru
*/

/******************************************************************************/
/***          Generated by IBExpert 2008.11.18 28.03.2009 18:26:26          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES UTF8;

CREATE DATABASE '192.168.1.2:oasup'
USER 'SYSDBA' PASSWORD 'xAcjH59x'
PAGE_SIZE 4096
DEFAULT CHARACTER SET UTF8;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_ACCESS_RIGHT_ID;
SET GENERATOR GEN_ACCESS_RIGHT_ID TO 5;

CREATE GENERATOR GEN_ACL_ID;
SET GENERATOR GEN_ACL_ID TO 200;

CREATE GENERATOR GEN_EA_FLDNUM;
SET GENERATOR GEN_EA_FLDNUM TO 1;

CREATE GENERATOR GEN_ETC;
SET GENERATOR GEN_ETC TO 1;

CREATE GENERATOR GEN_GROUPS_ID;
SET GENERATOR GEN_GROUPS_ID TO 3;

CREATE GENERATOR GEN_ID_ALL;
SET GENERATOR GEN_ID_ALL TO 10000;

CREATE GENERATOR GEN_MEMBERSHIP_ID;
SET GENERATOR GEN_MEMBERSHIP_ID TO 4;

CREATE GENERATOR IBE$TODO_ITEM_ID_GEN;
SET GENERATOR IBE$TODO_ITEM_ID_GEN TO 1;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION DELETE_ERROR 'Невозможно удалить';

CREATE EXCEPTION INSERT_ERROR 'Ошибка вставки записи';

CREATE EXCEPTION NEVER_PARAMS_VALUES 'Неверные значения параметров';

CREATE EXCEPTION PARAM_EXIST 'Параметр уже существует';

CREATE EXCEPTION VALUE_EXIST 'Значение уже существует';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE CALCULATE_RES_REMAINDER (
    ID_LINK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE DEL_ALL_EA_BYOBJID (
    ID_LINK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE EA_NUM_BY_NAME (
    FIELDNAME VARCHAR(64))
RETURNS (
    ID_EA INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_ACT_LIST_PRAGMA_HYP_EIDOS (
    ID_LINK2PRAGMAEIDOS INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    HYP_NAME VARCHAR(255),
    PRAGMA_DATE DATE,
    LINK2PRAGMA INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_ALTCAPTIONS (
    ID_EIDOS INTEGER)
RETURNS (
    FIELD_NAME VARCHAR(64),
    NEWCAPTION VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_ATTRIBUTES_BYNUM (
    FIELDNUM INTEGER)
RETURNS (
    ID INTEGER,
    ID_CLASS INTEGER,
    FIELDNAME VARCHAR(64),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    LINKEDLEVELHP INTEGER,
    LINKEDOBJACT INTEGER,
    VISIBLE INTEGER,
    MULTILNK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_DATE (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING TIMESTAMP,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_DLL (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_INT (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_LNKH (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_MULTITABLE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_LNKP (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_MULTILNKH (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_NUM (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING FLOAT,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_RB (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_SECUR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_LIST_STR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_NEWFIELDNAME
RETURNS (
    FLDNAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_RB (
    ID_EA INTEGER)
RETURNS (
    ID_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    ID_RB INTEGER,
    ID_VALUE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_DATE (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_DLL (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_INT (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_LNKH (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_LNKP (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_NUM (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_RB (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EA_TEMP_LIST_STR (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EIDOS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EIDOS_LIST (
    EIDOS_SPEC VARCHAR(64))
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_EIDOSEXTRAATTRIB_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    NAMESTOREDPROC VARCHAR(64),
    TEMPORALLISTSPNAME VARCHAR(64),
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_HYPOTESIS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_HYPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_HYPOTESIS_NAME_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_ID_TOPSPECIES (
    SPECIES VARCHAR(64))
RETURNS (
    ID_TOP_SPECIES INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_LINKED_HYPLIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_LINKED_PRAGMALIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_PRAGMA INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_PRAGMA (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_PRAGMA_LIST (
    ID_EIDOS INTEGER,
    ID_HYP_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_PRAGMA_NAME_LIST
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_PRAGMA_WITH_HIPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    HYP_NAME VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_RB (
    ID_VALUE INTEGER,
    ID_RB INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SET_EA_DLL (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    KEYVALUE VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EA_LNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EA_MULTILNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_INLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SET_EA_RB (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    ID_RB INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EA_SIMPLE_DATE (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING TIMESTAMP,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EA_SIMPLE_INT (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EA_SIMPLE_NUM (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EA_SIMPLE_STR (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_EIDOS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SET_EIDOSEXTRAATTRIB (
    ID INTEGER,
    ID_EIDOS INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SET_HYPOTESIS (
    ID INTEGER,
    ID_EIDOS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SET_LEVEL_INEIDOS
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_PRAGMA (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_FOREIGN_KEY
RETURNS (
    PK VARCHAR(31),
    TABLENAME VARCHAR(31),
    FIELDNAMEPK VARCHAR(31),
    FK VARCHAR(31),
    TABLENAMESOURCE VARCHAR(31),
    FIELDNAMEFK VARCHAR(31))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_RB_FIELDS (
    RB_TABLENAME VARCHAR(31))
RETURNS (
    RDB$RELATION_NAME VARCHAR(31),
    RDB$FIELD_NAME VARCHAR(31),
    RDB$DESCRIPTION BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    RDB$FIELD_TYPE SMALLINT,
    RDB$TYPE_NAME VARCHAR(31),
    RDB$FIELD_LENGTH SMALLINT,
    RDB$FIELD_POSITION SMALLINT,
    RDB$FIELD_SCALE SMALLINT,
    RDB$FIELD_SUB_TYPE SMALLINT,
    RDB$FIELD_PRECISION SMALLINT,
    RDB$SEGMENT_LENGTH SMALLINT,
    RDB$NULL_FLAG SMALLINT,
    RDB$CONSTRAINT_NAME VARCHAR(31),
    RDB$CONSTRAINT_TYPE VARCHAR(11))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_RIGHTS_FOR_OBJECT (
    ID_OBJ INTEGER)
RETURNS (
    GROUP_NAME VARCHAR(255),
    RIGHT_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_TEMPORALY_VALUE (
    ID_HEADER INTEGER)
RETURNS (
    ID_LINK INTEGER,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_TYPE
RETURNS (
    ID SMALLINT,
    FIELD_TYPE SMALLINT,
    FIELD_TYPE_NAME VARCHAR(31),
    TYPE_NAME VARCHAR(62),
    FIELD_LENGTH SMALLINT,
    FIELD_SCALE SMALLINT,
    FIELD_SUB_TYPE SMALLINT,
    FIELD_PRECISION SMALLINT,
    SEGMENT_LENGTH SMALLINT,
    CAPTION VARCHAR(62))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_USER_OBJ (
    TYPE_OBJ SMALLINT)
RETURNS (
    ID INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_USER_OBJECTS
RETURNS (
    ID_OBJECT INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_USER_PRAGMA
RETURNS (
    MAX_OF_ACCESS_RIGHT INTEGER,
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_GET_VAR_DT
RETURNS (
    DT TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_CURRENT_USER
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_ETC (
    OBJ VARCHAR(512),
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_ETC_ALL (
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_ETC_ALL2USER (
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_ETC_PARAMETERS (
    OBJECT_ID INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_ETC_PARAMETERS2USER (
    OBJECT VARCHAR(512),
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE SMALLINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_FLOATS (
    PARAM_LINKS INTEGER)
RETURNS (
    ID INTEGER,
    "VALUE" DOUBLE PRECISION,
    LINKS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_RB_DESCRIBER
RETURNS (
    ID INTEGER,
    RB_NAME VARCHAR(255),
    RB_TABLENAME VARCHAR(64),
    IS_RB_IERARCHY SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_READ_USER_INFO
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_SET_ETC (
    ID INTEGER,
    OBJECT VARCHAR(512),
    ID_USER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_SET_ETC2OBJ (
    UNAME VARCHAR(64),
    OLD_OBJECT VARCHAR(512),
    NEW_OBJECT VARCHAR(512))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_SET_PARAMETERS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 4096)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_SET_RENAME_PARAMETER (
    ID INTEGER,
    NEW_NAME VARCHAR(250))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SP_SET_RIGHT (
    GID INTEGER,
    OID INTEGER,
    RID INTEGER,
    MODE SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SP_SET_VAR_DT (
    DT TIMESTAMP)
AS
BEGIN
  EXIT;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ACCESS_RIGHT (
    ID    INTEGER NOT NULL,
    AO    SMALLINT DEFAULT 0 NOT NULL,
    A     SMALLINT DEFAULT 0 NOT NULL,
    W     SMALLINT DEFAULT 0 NOT NULL,
    D     SMALLINT DEFAULT 0 NOT NULL,
    R     SMALLINT DEFAULT 0 NOT NULL,
    NAME  VARCHAR(64)
);

CREATE TABLE ACL (
    ID            INTEGER NOT NULL,
    GID           INTEGER NOT NULL,
    ACCESS_RIGHT  INTEGER NOT NULL,
    ID_OBJECT     INTEGER NOT NULL
);

CREATE TABLE EIDOS (
    ID         INTEGER NOT NULL,
    ID_PARENT  INTEGER,
    NAME       VARCHAR(255) NOT NULL,
    SPECIES    VARCHAR(64),
    "LEVEL"    SMALLINT DEFAULT 1 NOT NULL
);

CREATE TABLE EIDOS_ALTCAPTION (
    ID_EIDOS    INTEGER,
    FIELDNAME   VARCHAR(64),
    NEWCAPTION  VARCHAR(255)
);

CREATE TABLE ETC (
    ID       INTEGER NOT NULL,
    OBJECT   VARCHAR(512) NOT NULL,
    ID_USER  INTEGER NOT NULL
);

CREATE TABLE ETC_PARAMETERS (
    ID            INTEGER NOT NULL,
    NAME          VARCHAR(250) NOT NULL,
    PARAM_TYPE    SMALLINT NOT NULL,
    ID_OBJECT     INTEGER NOT NULL,
    DATE_VALUE    TIMESTAMP,
    FLOAT_VALUE   DOUBLE PRECISION,
    INT_VALUE     BIGINT,
    STRING_VALUE  VARCHAR(255),
    BLOB_VALUE    BLOB SUB_TYPE 0 SEGMENT SIZE 4096
);

CREATE TABLE EXTRAATRIB_RB (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    INTEGER NOT NULL,
    ID_RB      INTEGER NOT NULL
);

CREATE TABLE EXTRAATTRIB_ALTCAPTION (
    ID_EIDOS    INTEGER,
    FIELDNAME   VARCHAR(64),
    NEWCAPTION  VARCHAR(255)
);

CREATE TABLE EXTRAATTRIB_DLL (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    VARCHAR(255),
    KEYVALUE   VARCHAR(255)
);

CREATE TABLE EXTRAATTRIB_HEADER (
    ID               INTEGER NOT NULL,
    ID_CLASS         INTEGER NOT NULL,
    FIELDNAME        VARCHAR(64),
    FIELDTYPE        INTEGER,
    CAPTION          VARCHAR(255) NOT NULL,
    ID_BELONGFOR     INTEGER,
    ID_RB_DESCRIBER  INTEGER,
    DLL_FILENAME     VARCHAR(64),
    DLL_PROCNAME     VARCHAR(64),
    TEMPORALITY      INTEGER,
    REQUIRED         INTEGER,
    LINKEDLEVELHP    INTEGER,
    LINKEDOBJACT     INTEGER,
    VISIBLE          INTEGER,
    LOCKED           INTEGER,
    MULTILNK         INTEGER,
    LNK_SPECIES      VARCHAR(64),
    LNK_EIDOSID      INTEGER,
    LNK_HYPID        INTEGER,
    LNK_NEEDLIST     INTEGER
);

CREATE TABLE EXTRAATTRIB_LNK (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    KEYVALUE   INTEGER,
    RATIO      FLOAT
);

CREATE TABLE EXTRAATTRIB_SIM_DATE (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    TIMESTAMP
);

CREATE TABLE EXTRAATTRIB_SIM_INT (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    INTEGER
);

CREATE TABLE EXTRAATTRIB_SIM_NUM (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    FLOAT
);

CREATE TABLE EXTRAATTRIB_SIM_STR (
    ID_HEADER  INTEGER NOT NULL,
    ID_LINK    INTEGER NOT NULL,
    "VALUE"    VARCHAR(255)
);

CREATE TABLE EXTRAATTRIB_SUPPORT (
    FIELDTYPE           INTEGER,
    NAMESTOREDPROC      VARCHAR(64),
    TEMPORALLISTSPNAME  VARCHAR(64),
    DESCRIBER           VARCHAR(255)
);

CREATE TABLE FIELDS_TYPE (
    ID               SMALLINT,
    FIELD_TYPE       SMALLINT NOT NULL,
    FIELD_TYPE_NAME  VARCHAR(31) NOT NULL,
    TYPE_NAME        VARCHAR(62),
    FIELD_LENGTH     SMALLINT,
    FIELD_SCALE      SMALLINT,
    FIELD_SUB_TYPE   SMALLINT,
    FIELD_PRECISION  SMALLINT,
    SEGMENT_LENGTH   SMALLINT,
    CAPTION          VARCHAR(62)
);

CREATE TABLE GROUPS (
    ID    INTEGER NOT NULL,
    NAME  VARCHAR(255) NOT NULL
);

CREATE TABLE HYPOTESIS (
    ID        INTEGER NOT NULL,
    ID_EIDOS  INTEGER NOT NULL
);

CREATE TABLE IBE$TODO (
    ITEM_ID             INTEGER NOT NULL,
    OBJECT_NAME         VARCHAR(64) CHARACTER SET UNICODE_FSS,
    OBJECT_TYPE         INTEGER,
    ITEM_PRIORITY       SMALLINT DEFAULT 0 NOT NULL,
    ITEM_STATE          SMALLINT DEFAULT 0 NOT NULL,
    ITEM_CAPTION        VARCHAR(255) NOT NULL,
    ITEM_DESCRIPTION    BLOB SUB_TYPE 1 SEGMENT SIZE 80,
    RESPONSIBLE_PERSON  VARCHAR(64),
    ITEM_TIMESTAMP      TIMESTAMP NOT NULL,
    ITEM_DEADLINE       DATE,
    ITEM_CATEGORY       VARCHAR(64),
    ITEM_OWNER          VARCHAR(64) CHARACTER SET UNICODE_FSS NOT NULL
);

CREATE TABLE ID_OBJ (
    ID         INTEGER,
    TYPE_OBJ   SMALLINT DEFAULT 0,
    ID_PARENT  INTEGER
);

CREATE TABLE IRB_HUMANS (
    ID                INTEGER NOT NULL,
    FIRSTNAME         VARCHAR(255),
    MIDDLENAME        VARCHAR(255),
    LASTNAME          VARCHAR(255),
    LNK_ORGANIZATION  INTEGER,
    JOB_NAME          VARCHAR(255)
);

CREATE TABLE IRB_OPERATIONS (
    ID    INTEGER NOT NULL,
    NAME  VARCHAR(255) NOT NULL
);

CREATE TABLE IRB_PLACESUSE (
    ID         INTEGER NOT NULL,
    ID_PARENT  INTEGER NOT NULL,
    NAME       VARCHAR(255) NOT NULL
);

CREATE TABLE IRB_RESOURCES (
    ID             INTEGER NOT NULL,
    ID_PARENT      INTEGER NOT NULL,
    NAME           VARCHAR(255) NOT NULL,
    LNK_UNITMESUR  INTEGER NOT NULL
);

CREATE TABLE IRB_STRUCTURES (
    ID                INTEGER NOT NULL,
    ID_PARENT         INTEGER NOT NULL,
    NAME              VARCHAR(255) NOT NULL,
    INN               VARCHAR(30),
    LNK_HUMANS_CHIEF  INTEGER
);

CREATE TABLE IRB_UNITMESUREMENT (
    ID         INTEGER NOT NULL,
    ID_PARENT  INTEGER NOT NULL,
    NAME       VARCHAR(255) NOT NULL
);

CREATE TABLE MEMBERSHIP (
    ID         INTEGER NOT NULL,
    GID        INTEGER NOT NULL,
    USER_NAME  VARCHAR(64) NOT NULL
);

CREATE TABLE MULTIPLEXLNK (
    ID         INTEGER NOT NULL,
    ID_LINK    INTEGER,
    ID_HEADER  INTEGER NOT NULL
);

CREATE TABLE PRAGMA (
    ID            INTEGER NOT NULL,
    ID_EIDOS      INTEGER,
    ID_HYPOTESIS  INTEGER
);

CREATE TABLE RB_DESCRIBER (
    ID              INTEGER NOT NULL,
    RB_NAME         VARCHAR(255) NOT NULL,
    RB_TABLENAME    VARCHAR(64) NOT NULL,
    IS_RB_IERARCHY  SMALLINT DEFAULT 0 NOT NULL,
    SQLSTRING       VARCHAR(255)
);

CREATE TABLE TEMPORALITY (
    ID         INTEGER NOT NULL,
    ID_LINK    INTEGER,
    DATE_TIME  TIMESTAMP,
    ID_HEADER  INTEGER NOT NULL
);

CREATE TABLE USERS (
    UID                  INTEGER NOT NULL,
    NAME                 VARCHAR(64) NOT NULL,
    ID_TYPE_ACCES_RIGHT  INTEGER NOT NULL,
    FULL_NAME            VARCHAR(255),
    DESCRIPTIONS         VARCHAR(255),
    IS_DELETED           SMALLINT DEFAULT 0,
    IS_DISABLED          SMALLINT DEFAULT 0
);

CREATE TABLE VAR_DT (
    USER_NAME  VARCHAR(64) DEFAULT user,
    DT         TIMESTAMP DEFAULT 'NOW'
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: VW_CONSTRAINTS */
CREATE VIEW VW_CONSTRAINTS(
    RDB$INDEX_NAME,
    RDB$RELATION_NAME,
    RDB$UNIQUE_FLAG,
    RDB$INDEX_INACTIVE,
    RDB$INDEX_TYPE,
    RDB$FIELD_NAME,
    RDB$FIELD_POSITION,
    RDB$CONSTRAINT_TYPE,
    RDB$CONSTRAINT_NAME)
AS
select i.rdb$index_name,
i.rdb$relation_name,
i.rdb$unique_flag,
i.rdb$index_inactive,
i.rdb$index_type,
isg.rdb$field_name,
isg.rdb$field_position,
c.RDB$CONSTRAINT_TYPE,
c.RDB$CONSTRAINT_NAME
from rdb$indices i
LEFT JOIN rdb$index_segments isg ON (isg.rdb$index_name = i.rdb$index_name)
LEFT JOIN rdb$relation_constraints c ON (i.rdb$index_name = c.rdb$index_name)
WHERE (not (c.RDB$CONSTRAINT_TYPE is NULL))
;



/* View: VW_FIELDS */
CREATE VIEW VW_FIELDS(
    RDB$RELATION_NAME,
    RDB$FORMAT,
    RDB$SYSTEM_FLAG,
    RDB$RELATION_ID,
    RDB$FIELD_NAME,
    RDB$DESCRIPTION,
    RDB$TYPE_NAME,
    RDB$FIELD_LENGTH,
    RDB$FIELD_POSITION,
    RDB$FIELD_TYPE,
    RDB$FIELD_SCALE,
    RDB$FIELD_SUB_TYPE,
    RDB$FIELD_PRECISION,
    RDB$SEGMENT_LENGTH,
    RDB$NULL_FLAG)
AS
SELECT RDB$RELATIONS.RDB$RELATION_NAME, RDB$RELATIONS.RDB$FORMAT, RDB$RELATIONS.RDB$SYSTEM_FLAG, RDB$RELATIONS.RDB$RELATION_ID, RDB$RELATION_FIELDS.RDB$FIELD_NAME, RDB$RELATION_FIELDS.RDB$DESCRIPTION, RDB$TYPES.RDB$TYPE_NAME, RDB$FIELDS.RDB$FIELD_LENGTH, RDB$RELATION_FIELDS.RDB$FIELD_POSITION, RDB$FIELDS.RDB$FIELD_TYPE, RDB$FIELDS.RDB$FIELD_SCALE, RDB$FIELDS.RDB$FIELD_SUB_TYPE, RDB$FIELDS.RDB$FIELD_PRECISION, RDB$FIELDS.RDB$SEGMENT_LENGTH, RDB$RELATION_FIELDS.RDB$NULL_FLAG
FROM RDB$RELATION_FIELDS
   INNER JOIN RDB$FIELDS ON (RDB$RELATION_FIELDS.RDB$FIELD_SOURCE = RDB$FIELDS.RDB$FIELD_NAME)
   INNER JOIN RDB$TYPES ON (RDB$FIELDS.RDB$FIELD_TYPE = RDB$TYPES.RDB$TYPE)
   INNER JOIN RDB$RELATIONS ON (RDB$RELATION_FIELDS.RDB$RELATION_NAME = RDB$RELATIONS.RDB$RELATION_NAME)
WHERE 
   (
      (RDB$TYPES.RDB$FIELD_NAME = 'RDB$FIELD_TYPE')
   and 
      (RDB$RELATIONS.RDB$SYSTEM_FLAG = 0)
   )
;



/* View: VW_USER_OBIECTS */
CREATE VIEW VW_USER_OBIECTS(
    ID_OBJECT,
    MAX_OF_ACCESS_RIGHT)
AS
SELECT ACL.ID_OBJECT, MAX( ACL.ACCESS_RIGHT ) MAX_OF_ACCESS_RIGHT
FROM MEMBERSHIP
   --INNER JOIN GROUPS ON (MEMBERSHIP.GID = GROUPS.ID)
   INNER JOIN ACL ON (MEMBERSHIP.GID = ACL.GID)
WHERE 
   (
      (MEMBERSHIP.USER_NAME = USER)
   )
GROUP BY ACL.ID_OBJECT
;


INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (5, 1, 1, 1, 1, 1, 'Администрирование');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (1, 0, 0, 0, 0, 1, 'Только чтение');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (2, 0, 0, 1, 0, 1, 'Изменение');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (3, 0, 1, 1, 0, 1, 'Изменение и добавление');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (4, 0, 1, 1, 1, 1, 'Полный доступ');
INSERT INTO ACCESS_RIGHT (ID, AO, A, W, D, R, NAME) VALUES (0, 0, 0, 0, 0, 0, 'Нет доступа');

COMMIT WORK;

INSERT INTO GROUPS (ID, NAME) VALUES (1, 'Администраторы');
INSERT INTO GROUPS (ID, NAME) VALUES (2, 'Пользователи');
INSERT INTO GROUPS (ID, NAME) VALUES (3, 'Бухгалтеры');

COMMIT WORK;

INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (1, 1, 1, 1);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (2, 1, 4, 2);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (3, 1, 4, 3);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (4, 1, 4, 4);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (5, 1, 4, 5);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (6, 1, 4, 20);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (7, 1, 4, 21);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (8, 1, 4, 22);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (9, 1, 4, 23);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (10, 1, 4, 24);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (11, 1, 4, 25);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (12, 1, 4, 27);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (13, 1, 4, 28);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (14, 1, 4, 30);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (15, 1, 4, 31);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (16, 1, 4, 32);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (17, 1, 4, 50);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (18, 1, 4, 60);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (19, 1, 4, 61);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (20, 1, 4, 62);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (21, 1, 4, 63);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (22, 1, 4, 70);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (23, 1, 4, 71);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (24, 1, 4, 72);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (25, 1, 4, 80);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (26, 1, 4, 81);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (27, 1, 4, 82);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (28, 1, 4, 90);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (29, 1, 4, 91);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (30, 1, 4, 92);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (31, 1, 4, 93);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (32, 1, 4, 94);
INSERT INTO ACL (ID, GID, ACCESS_RIGHT, ID_OBJECT) VALUES (33, 1, 4, 95);

COMMIT WORK;

INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (1, 0, 'root', 'ALL', 1);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (2, 1, 'Объекты учета', 'OBJ', 2);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (3, 1, 'Подучетные действия', 'ACT', 2);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (4, 1, 'Ресурсы', 'RES', 2);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (5, 1, 'Нормативно-справочная информация', 'NSI', 2);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (20, 2, 'Оборудование', 'OBJ', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (21, 20, 'Вычислительная техника', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (22, 20, 'Сетевое', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (23, 21, 'ПК (системные блоки)', 'OBJ', 5);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (24, 21, 'Серверы', 'OBJ', 5);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (25, 20, 'Мониторы', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (27, 20, 'Принтеры', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (28, 20, 'Сканеры', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (30, 20, 'Консоли управления', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (31, 22, 'Маршрутизаторы', 'OBJ', 5);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (32, 22, 'Коммутаторы', 'OBJ', 5);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (50, 2, 'Учетные записи пользователей', 'OBJ', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (60, 2, 'Программное обеспечение', 'OBJ', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (61, 60, 'Операционные системы', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (62, 60, 'Среднего уровня (портал, информационный сайт...)', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (63, 60, 'Прикладное', 'OBJ', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (70, 3, 'Эксплуатация', 'ACT', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (71, 3, 'Осмотры', 'ACT', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (72, 3, 'Ремонты', 'ACT', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (80, 4, 'Запасные части', 'RES', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (81, 4, 'Расходные материалы', 'RES', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (82, 81, 'Картриджи', 'RES', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (90, 5, 'Единицы измерения', 'NSI', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (91, 5, 'Список работников', 'NSI', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (92, 5, 'Здания и корпуса', 'NSI', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (93, 5, 'Компьютерная техника', 'NSI', 3);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (94, 93, 'Тип процессора', 'NSI', 4);
INSERT INTO EIDOS (ID, ID_PARENT, NAME, SPECIES, "LEVEL") VALUES (95, 93, 'Тип памяти', 'NSI', 4);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1000, 1, 'HypName', 1, 'Наименование', 1, NULL, NULL, NULL, 0, 1, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1001, 1, 'PragmaDate', 11, 'Дата создания(получения)', 2, NULL, NULL, NULL, 0, 1, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1002, 1, 'Security', 105, 'Право доступа к объекту для пользователя в контексте роли', 1, NULL, NULL, NULL, 0, 0, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1003, 3, 'LnkOBJ', 104, 'Ссылка на экземпляр объекта учета над которым проводилось действие', 2, NULL, NULL, NULL, 0, 1, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1004, 4, 'LNK_ForkedRES', 104, 'Ссылка на экземпляр ресурса, от которого был отщеплен данный экземпляр', 2, NULL, NULL, NULL, 0, 0, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1005, 4, 'Remainder', 6, 'Остаток', 2, NULL, NULL, NULL, 0, 0, 0, 0, 1, 1, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1006, 4, 'LNK_ACTBelongFor', 104, 'Ссылка на действие на которое списан ресурс', 2, NULL, NULL, NULL, 0, 0, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (1007, 4, 'Quantity', 6, 'Количество', 2, NULL, NULL, NULL, 0, 1, 0, 0, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2001, 20, 'link2building', 103, 'Размещение', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 92, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2002, 20, 'Dateinituse', 11, 'Дата ввода в эксплуатацию', 2, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2003, 20, 'CheckNumber', 1, 'Приобретено по счету', 2, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2004, 20, 'AccMonth4use', 3, 'Срок полезного использования(мес)', 1, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2005, 20, 'GuarantyMonths', 3, 'Гарантийный срок(мес)', 2, NULL, NULL, NULL, 0, 1, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2006, 20, 'serialNumber', 1, 'Серийный номер', 2, NULL, NULL, NULL, 0, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2007, 20, 'Internalcodever', 1, 'Версия прошивки', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2008, 20, 'link2worker', 103, 'Ответственное лицо', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 91, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2009, 20, 'Developer', 1, 'Производитель', 1, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2010, 20, 'Developercontakts', 1, 'Контакная информация производителя', 1, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2011, 21, 'IPAdress', 1, 'IP адрес', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2012, 21, 'CPUType', 103, 'Тип CPU', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 94, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2013, 21, 'HDDVolume', 3, 'Емкость диска(ов) ГБ', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2014, 21, 'RAMType', 103, 'Тип RAM', 2, NULL, NULL, NULL, 1, 0, 0, 0, 1, 0, 0, 'NSI', 95, 0, 1);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2015, 21, 'RAMVolume', 3, 'Объем оперативной памяти МБ', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2016, 21, 'DVDOnboard', 5, 'Установлен привод DVD', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);
INSERT INTO EXTRAATTRIB_HEADER (ID, ID_CLASS, FIELDNAME, FIELDTYPE, CAPTION, ID_BELONGFOR, ID_RB_DESCRIBER, DLL_FILENAME, DLL_PROCNAME, TEMPORALITY, REQUIRED, LINKEDLEVELHP, LINKEDOBJACT, VISIBLE, LOCKED, MULTILNK, LNK_SPECIES, LNK_EIDOSID, LNK_HYPID, LNK_NEEDLIST) VALUES (2020, 24, 'RAIDLevel', 3, 'Уровень RAID', 2, NULL, NULL, NULL, 1, 0, 0, NULL, 1, 0, 0, NULL, NULL, NULL, 0);

COMMIT WORK;

INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (1, 'GET_EA_LIST_STR', 'GET_EA_TEMP_LIST_STR', 'ft_String');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (5, 'GET_EA_LIST_INT', 'GET_EA_TEMP_LIST_INT', 'ft_Boolean');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (3, 'GET_EA_LIST_INT', 'GET_EA_TEMP_LIST_INT', 'ft_Integer');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (6, 'GET_EA_LIST_NUM', 'GET_EA_TEMP_LIST_NUM', 'ft_Float');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (11, 'GET_EA_LIST_DATE', 'GET_EA_TEMP_LIST_DATE', 'ft_DateTime');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (101, 'GET_EA_LIST_RB', 'GET_EA_TEMP_LIST_RB', 'ft_RB');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (102, 'GET_EA_LIST_DLL', 'GET_EA_TEMP_LIST_DLL', 'ft_DLL');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (103, 'GET_EA_LIST_LNKH', 'GET_EA_TEMP_LIST_LNKH', 'ft_LinkHypotesis');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (104, 'GET_EA_LIST_LNKP', 'GET_EA_TEMP_LIST_LNKP', 'ft_LinkPragma');
INSERT INTO EXTRAATTRIB_SUPPORT (FIELDTYPE, NAMESTOREDPROC, TEMPORALLISTSPNAME, DESCRIBER) VALUES (105, 'GET_EA_LIST_SECUR', NULL, 'ft_Security');

COMMIT WORK;

INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (7, 7, 'SHORT', 'SMALLINT', NULL, 0, NULL, NULL, NULL, 'короткое целое от -32767 до 32768');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (16, 16, 'INT64', 'BIGINT', NULL, 0, NULL, 0, NULL, 'большое целое от -9223372036854775807 до 9223372036854775808');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (10, 10, 'FLOAT', 'FLOAT', NULL, 0, NULL, NULL, NULL, 'вещественное одинарной точности');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (27, 27, 'DOUBLE', 'DOUBLE', NULL, 0, NULL, NULL, NULL, 'вещественное двойной точности');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (17, 16, 'INT64', 'NUMERIC', NULL, -2, 1, 15, NULL, 'NUMERIC');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (18, 16, 'INT64', 'DECIMAL', NULL, -2, 2, 15, NULL, 'DECIMAL');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (12, 12, 'DATE', 'DATE', NULL, 0, NULL, NULL, NULL, 'дата');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (13, 13, 'TIME', 'TIME', NULL, 0, NULL, NULL, NULL, 'время');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (35, 35, 'TIMESTAMP', 'TIMESTAMP', NULL, 0, NULL, NULL, NULL, 'дата со временем');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (14, 14, 'TEXT', 'CHAR', 10, 0, NULL, NULL, NULL, 'строка,дополненная пробелами до своей длины');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (37, 37, 'VARYING', 'VARCHAR', 10, 0, NULL, NULL, NULL, 'строка');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (261, 261, 'BLOB', 'BLOB', NULL, 0, 0, NULL, 4096, 'большой бинарный объект (рисунок, файл и т.п.)');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (262, 261, 'BLOB', 'BLOB', NULL, 0, 1, NULL, 4096, 'большой текстовый объект');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (1, 1, 'FK', 'FK', NULL, NULL, NULL, NULL, NULL, 'ссылка на справочник');
INSERT INTO FIELDS_TYPE (ID, FIELD_TYPE, FIELD_TYPE_NAME, TYPE_NAME, FIELD_LENGTH, FIELD_SCALE, FIELD_SUB_TYPE, FIELD_PRECISION, SEGMENT_LENGTH, CAPTION) VALUES (8, 8, 'INTEGER', 'INTEGER', NULL, 0, NULL, NULL, NULL, 'целое');

COMMIT WORK;

INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (1, 0, 0);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (2, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (3, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (4, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (5, 0, 1);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (20, 0, 2);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (21, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (22, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (23, 0, 21);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (24, 0, 21);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (25, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (27, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (28, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (30, 0, 20);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (31, 0, 22);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (32, 0, 22);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (50, 0, 2);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (60, 0, 2);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (61, 0, 60);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (62, 0, 60);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (63, 0, 60);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (70, 0, 3);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (71, 0, 3);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (72, 0, 3);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (80, 0, 4);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (81, 0, 4);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (82, 0, 81);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (90, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (91, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (92, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (93, 0, 5);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (94, 0, 93);
INSERT INTO ID_OBJ (ID, TYPE_OBJ, ID_PARENT) VALUES (95, 0, 93);

COMMIT WORK;

INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (1, 1, 'SYSDBA');
INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (2, 2, 'SYSDBA');
INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (3, 3, 'SYSDBA');
INSERT INTO MEMBERSHIP (ID, GID, USER_NAME) VALUES (4, 2, 'test');

COMMIT WORK;

INSERT INTO USERS (UID, NAME, ID_TYPE_ACCES_RIGHT, FULL_NAME, DESCRIPTIONS, IS_DELETED, IS_DISABLED) VALUES (9, 'SYSDBA', 28, 'Администратор БД', '', 0, 0);

COMMIT WORK;

INSERT INTO VAR_DT (USER_NAME, DT) VALUES ('SYSDBA', '2009-03-28 18:24:12');

COMMIT WORK;


/* Check constraints definition */

ALTER TABLE IRB_RESOURCES ADD CONSTRAINT CHK_IRB_RESOURCES check (((ID_PARENT =-1) OR ( ID_PARENT = ANY(SELECT ID FROM IRB_RESOURCES) )) and ID_PARENT<>ID);
ALTER TABLE ID_OBJ ADD CHECK (TYPE_OBJ=0 or TYPE_OBJ=1 or TYPE_OBJ=2);
ALTER TABLE EIDOS ADD CONSTRAINT CHK_EIDOS_PARENT check (((ID_PARENT=0) OR ( ID_PARENT = ANY(SELECT ID FROM EIDOS) )) and ID_PARENT<>ID);
ALTER TABLE ID_OBJ ADD check (((ID_PARENT=0) OR ( ID_PARENT = ANY(SELECT ID FROM ID_OBJ) )) and ID_PARENT<>ID);
ALTER TABLE IRB_STRUCTURES ADD CONSTRAINT CHK_IRB_STRUCTURES check (((ID_PARENT=0) OR ( ID_PARENT = ANY(SELECT ID FROM IRB_STRUCTURES) )) and ID_PARENT<>ID);
ALTER TABLE IRB_PLACESUSE ADD CONSTRAINT CHK_IRB_PLACESUSE check (((ID_PARENT is NULL) OR ( ID_PARENT = ANY(SELECT ID FROM IRB_PLACESUSE) )) and ID_PARENT<>ID);
ALTER TABLE IBE$TODO ADD CHECK ((ITEM_PRIORITY >=0) AND (ITEM_PRIORITY <=5));
ALTER TABLE IBE$TODO ADD CHECK (ITEM_STATE IN (0, 1));


/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE ID_OBJ ADD CONSTRAINT UNQ_ID_OBJ UNIQUE (ID);
ALTER TABLE USERS ADD UNIQUE (NAME);
ALTER TABLE VAR_DT ADD CONSTRAINT UNQ_VAR_DT UNIQUE (USER_NAME);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCESS_RIGHT ADD CONSTRAINT PK_ACCESS_RIGHT PRIMARY KEY (ID);
ALTER TABLE ACL ADD CONSTRAINT PK_ACL PRIMARY KEY (ID);
ALTER TABLE EIDOS ADD CONSTRAINT PK_EIDOS PRIMARY KEY (ID);
ALTER TABLE ETC ADD CONSTRAINT PK_ETC PRIMARY KEY (ID);
ALTER TABLE ETC_PARAMETERS ADD CONSTRAINT PK_ETC_PARAMETERS PRIMARY KEY (ID);
ALTER TABLE EXTRAATRIB_RB ADD CONSTRAINT PK_EXTRAATRIB_RB PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_DLL ADD CONSTRAINT PK_EXTRAATTRIB_DLL PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_HEADER ADD CONSTRAINT PK_EXTRAATTRIB_HEADER PRIMARY KEY (ID);
ALTER TABLE EXTRAATTRIB_LNK ADD CONSTRAINT PK_EXTRAATTRIB_LNK PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_DATE ADD CONSTRAINT PK_EXTRAATTRIB_SIM_DATE PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_INT ADD CONSTRAINT PK_EXTRAATTRIB_SIM_INT PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_NUM ADD CONSTRAINT PK_EXTRAATTRIB_SIM_NUM PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE EXTRAATTRIB_SIM_STR ADD CONSTRAINT PK_EXTRAATTRIB_SIM_STR PRIMARY KEY (ID_HEADER, ID_LINK);
ALTER TABLE GROUPS ADD CONSTRAINT PK_GROUPS PRIMARY KEY (ID);
ALTER TABLE HYPOTESIS ADD CONSTRAINT PK_HYPOTESIS PRIMARY KEY (ID);
ALTER TABLE IBE$TODO ADD PRIMARY KEY (ITEM_ID);
ALTER TABLE IRB_HUMANS ADD CONSTRAINT PK_IRB_HUMANS PRIMARY KEY (ID);
ALTER TABLE IRB_OPERATIONS ADD CONSTRAINT PK_IRB_OPERATIONS PRIMARY KEY (ID);
ALTER TABLE IRB_PLACESUSE ADD CONSTRAINT PK_IRB_PLACESUSE PRIMARY KEY (ID);
ALTER TABLE IRB_RESOURCES ADD CONSTRAINT PK_IRB_RESOURCES PRIMARY KEY (ID);
ALTER TABLE IRB_STRUCTURES ADD CONSTRAINT PK_IRB_STRUCTURES PRIMARY KEY (ID);
ALTER TABLE IRB_UNITMESUREMENT ADD CONSTRAINT PK_IRB_UNITMESUREMENT PRIMARY KEY (ID);
ALTER TABLE MEMBERSHIP ADD CONSTRAINT PK_MEMBERSHIP PRIMARY KEY (ID);
ALTER TABLE MULTIPLEXLNK ADD CONSTRAINT PK_MULTIPLEXLNK PRIMARY KEY (ID);
ALTER TABLE PRAGMA ADD CONSTRAINT PK_PRAGMA PRIMARY KEY (ID);
ALTER TABLE RB_DESCRIBER ADD CONSTRAINT PK_RB_DESCRIBER PRIMARY KEY (ID);
ALTER TABLE TEMPORALITY ADD CONSTRAINT PK_TEMPORALITY PRIMARY KEY (ID);
ALTER TABLE USERS ADD PRIMARY KEY (UID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE ACL ADD CONSTRAINT FK_ACL FOREIGN KEY (ACCESS_RIGHT) REFERENCES ACCESS_RIGHT (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACL ADD CONSTRAINT FK_ACL_GID FOREIGN KEY (GID) REFERENCES GROUPS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ETC_PARAMETERS ADD CONSTRAINT FK_ETC_PARAMETERS FOREIGN KEY (ID_OBJECT) REFERENCES ETC (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE HYPOTESIS ADD CONSTRAINT FK_HYPOTESIS FOREIGN KEY (ID_EIDOS) REFERENCES EIDOS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE IRB_HUMANS ADD CONSTRAINT FK_IRB_HUMANS FOREIGN KEY (LNK_ORGANIZATION) REFERENCES IRB_STRUCTURES (ID);
ALTER TABLE IRB_RESOURCES ADD CONSTRAINT FK_IRB_RESOURCES_LNK_UNITMESUR FOREIGN KEY (LNK_UNITMESUR) REFERENCES IRB_UNITMESUREMENT (ID);
ALTER TABLE IRB_STRUCTURES ADD CONSTRAINT FK_IRB_STRUCTURES FOREIGN KEY (LNK_HUMANS_CHIEF) REFERENCES IRB_HUMANS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MEMBERSHIP ADD CONSTRAINT FK_MEMBERSHIP FOREIGN KEY (GID) REFERENCES GROUPS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PRAGMA ADD CONSTRAINT FK_PRAGMA FOREIGN KEY (ID_HYPOTESIS) REFERENCES HYPOTESIS (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TEMPORALITY ADD CONSTRAINT FK_TEMPORALITY FOREIGN KEY (ID_HEADER) REFERENCES EXTRAATTRIB_HEADER (ID) ON DELETE CASCADE ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX ACL_IDX_GID ON ACL (GID);
CREATE INDEX ACL_IDX_ID_OBJECT ON ACL (ID_OBJECT);
CREATE INDEX EIDOS_IDX1 ON EIDOS (ID_PARENT);
CREATE INDEX ETC_IDX_USER ON ETC (ID_USER);
CREATE INDEX ETC_PARAMETERS_IDX1 ON ETC_PARAMETERS (ID, ID_OBJECT);
CREATE INDEX IDX_EXTRAATRIB_RB_ID_HEADER ON EXTRAATRIB_RB (ID_HEADER);
CREATE INDEX IDX_EXTRAATRIB_RB_VAL ON EXTRAATRIB_RB ("VALUE");
CREATE INDEX EXTRAATTRIB_HEADER_IDX1 ON EXTRAATTRIB_HEADER (ID_CLASS);
CREATE INDEX IDX_EXTRAATTRIB_HEADER_FIELDNAM ON EXTRAATTRIB_HEADER (FIELDNAME);
CREATE INDEX EXTRAATTRIB_SIM_STR_IDX1 ON EXTRAATTRIB_SIM_STR (ID_LINK);
CREATE UNIQUE INDEX EXTRAATTRIB_SUPPORT_IDX1 ON EXTRAATTRIB_SUPPORT (FIELDTYPE);
CREATE INDEX HYPOTESIS_IDX1 ON HYPOTESIS (ID_EIDOS);
CREATE INDEX IBE$TODO_BY_OBJECTNAME ON IBE$TODO (OBJECT_NAME);
CREATE INDEX ID_OBJ_IDX1 ON ID_OBJ (ID_PARENT);
CREATE INDEX ID_OBJ_IDX_ID ON ID_OBJ (ID);
CREATE INDEX ID_OBJ_TYPE_OBJ ON ID_OBJ (TYPE_OBJ);
CREATE INDEX MEMBERSHIP_IDX_GID ON MEMBERSHIP (GID);
CREATE INDEX MEMBERSHIP_IDX_USER ON MEMBERSHIP (USER_NAME);
CREATE INDEX TEMPORALITY_IDX1 ON TEMPORALITY (ID_LINK);
CREATE DESCENDING INDEX TEMPORALITY_IDX2 ON TEMPORALITY (DATE_TIME);
CREATE INDEX TEMPORALITY_IDX3 ON TEMPORALITY (ID_HEADER);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: ACCESS_RIGHT_BI */
CREATE TRIGGER ACCESS_RIGHT_BI FOR ACCESS_RIGHT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ACCESS_RIGHT_ID,1);
END
^

/* Trigger: ACL_BI */
CREATE TRIGGER ACL_BI FOR ACL
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ACL_ID,1);
END
^

/* Trigger: EIDOS_AD_DELETE_FROM_ACL */
CREATE TRIGGER EIDOS_AD_DELETE_FROM_ACL FOR EIDOS
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from id_obj where id=old.id;
  delete from ACL where ACL.id_object=old.id;
end
^

/* Trigger: EIDOS_AI_SET_DEF_RIGHT */
CREATE TRIGGER EIDOS_AI_SET_DEF_RIGHT FOR EIDOS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  insert into id_obj(id,type_obj,id_parent)  values(new.id,0,new.id_parent);
  insert into ACL(GID,access_right, id_object)
  SELECT ACL.GID, ACL.ACCESS_RIGHT,new.id
FROM ACL
WHERE 
   (
      (ACL.ID_OBJECT = new.id_parent)
   );
end
^

/* Trigger: EIDOS_AU0 */
CREATE TRIGGER EIDOS_AU0 FOR EIDOS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if((new.id<>old.id) or (new.id_parent<>old.id_parent) ) then
    update id_obj set id=new.id,id_parent=new.id_parent where id=old.id;
end
^

/* Trigger: EIDOS_BI0 */
CREATE TRIGGER EIDOS_BI0 FOR EIDOS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 IF (NEW.ID IS NULL) THEN
  NEW.ID = GEN_ID(GEN_ID_ALL,1);
end
^

/* Trigger: EIDOS_BI0_SET_LEVEL */
CREATE TRIGGER EIDOS_BI0_SET_LEVEL FOR EIDOS
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
DECLARE VARIABLE l INTEGER;
begin
if (new.id_parent>0) then
 select eidos."LEVEL"+1 from eidos where eidos.id=new.id_parent into :l;
else l=1;
 new."LEVEL"=:l;
end
^

/* Trigger: ETC_ID_AUTOINCREMENT */
CREATE TRIGGER ETC_ID_AUTOINCREMENT FOR ETC
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ETC,1);
END
^

/* Trigger: ETC_PARAMETERS_ID_AUTOINCREMENT */
CREATE TRIGGER ETC_PARAMETERS_ID_AUTOINCREMENT FOR ETC_PARAMETERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ETC,1);
END
^

/* Trigger: EXTRAATTRIB_HEADER_BI0 */
CREATE TRIGGER EXTRAATTRIB_HEADER_BI0 FOR EXTRAATTRIB_HEADER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: GROUPS_BI */
CREATE TRIGGER GROUPS_BI FOR GROUPS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_GROUPS_ID,1);
END
^

/* Trigger: HYPOTESIS_AD_DELETE_FROM_ACL */
CREATE TRIGGER HYPOTESIS_AD_DELETE_FROM_ACL FOR HYPOTESIS
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from id_obj where id=old.id;
  delete from ACL where ACL.id_object=old.id;
end
^

/* Trigger: HYPOTESIS_AI_SET_DEF_RIGHT */
CREATE TRIGGER HYPOTESIS_AI_SET_DEF_RIGHT FOR HYPOTESIS
ACTIVE AFTER INSERT POSITION 0
AS
begin
   insert into id_obj(id,type_obj,id_parent)  values(new.id,1,new.id_eidos);
   insert into ACL(GID,access_right, id_object)
    SELECT ACL.GID, ACL.ACCESS_RIGHT,new.id
        FROM ACL
    WHERE 
    (
        (ACL.ID_OBJECT = new.id_eidos)
    );
end
^

/* Trigger: HYPOTESIS_AU0 */
CREATE TRIGGER HYPOTESIS_AU0 FOR HYPOTESIS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if((new.id<>old.id) or (new.id_eidos<>old.id_eidos) ) then
    update id_obj set id=new.id,id_parent=new.id_eidos where id=old.id;
end
^

/* Trigger: HYPOTESIS_BI0 */
CREATE TRIGGER HYPOTESIS_BI0 FOR HYPOTESIS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 IF (NEW.ID IS NULL) THEN
  NEW.ID = GEN_ID(GEN_ID_ALL,1);
end
^

/* Trigger: IBE$TODO_ITEM_ID_BI */
CREATE TRIGGER IBE$TODO_ITEM_ID_BI FOR IBE$TODO
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.item_id IS NULL) THEN
    NEW.item_id = GEN_ID(ibe$todo_item_id_gen,1);
  NEW.item_timestamp = 'now';
  NEW.item_state = 0;
  NEW.item_owner = USER;
  IF (NEW.item_priority IS NULL) THEN
    NEW.item_priority = 0;
END
^

/* Trigger: ID_OBJ_BD0 */
CREATE TRIGGER ID_OBJ_BD0 FOR ID_OBJ
ACTIVE BEFORE DELETE POSITION 0
AS
DECLARE VARIABLE ID INTEGER;
begin
  if (old.type_obj=0) then select id from eidos where id=old.id into :id;
  if (old.type_obj=1) then select id from hypotesis where id=old.id into :id;
  if (old.type_obj=0) then select id from pragma where id=old.id into :id;
  if (:id is not NULL) then exception DELETE_ERROR;
end
^

/* Trigger: ID_OBJ_BI0 */
CREATE TRIGGER ID_OBJ_BI0 FOR ID_OBJ
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
DECLARE VARIABLE ID INTEGER;
begin
  if (new.type_obj=0) then select id from eidos where id=new.id and id_parent=new.id_parent into :id;
  if (new.type_obj=1) then select id from hypotesis where id=new.id and id_eidos=new.id_parent into :id;
  if (new.type_obj=2) then select id from pragma where id=new.id and id_hypotesis=new.id_parent into :id;
  if (:id is NULL) then exception INSERT_ERROR;
end
^

/* Trigger: IRB_HUMANS_BI */
CREATE TRIGGER IRB_HUMANS_BI FOR IRB_HUMANS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_OPERATIONS_BI */
CREATE TRIGGER IRB_OPERATIONS_BI FOR IRB_OPERATIONS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_PLACESUSE_BI */
CREATE TRIGGER IRB_PLACESUSE_BI FOR IRB_PLACESUSE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_RESOURCES_BI */
CREATE TRIGGER IRB_RESOURCES_BI FOR IRB_RESOURCES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_STUCTURES_BI */
CREATE TRIGGER IRB_STUCTURES_BI FOR IRB_STRUCTURES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: IRB_UNITMESUREMENT_BI */
CREATE TRIGGER IRB_UNITMESUREMENT_BI FOR IRB_UNITMESUREMENT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: MEMBERSHIP_BI */
CREATE TRIGGER MEMBERSHIP_BI FOR MEMBERSHIP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_MEMBERSHIP_ID,1);
END
^

/* Trigger: MULTIPLEXLNK_BI */
CREATE TRIGGER MULTIPLEXLNK_BI FOR MULTIPLEXLNK
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: PRAGMA_AD_DELETE_FROM_ACL */
CREATE TRIGGER PRAGMA_AD_DELETE_FROM_ACL FOR PRAGMA
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from id_obj where id=old.id;
  delete from ACL where ACL.id_object=old.id;
end
^

/* Trigger: PRAGMA_AI_SET_DEF_RIGHT */
CREATE TRIGGER PRAGMA_AI_SET_DEF_RIGHT FOR PRAGMA
ACTIVE AFTER INSERT POSITION 0
AS
begin
  insert into id_obj(id,type_obj,id_parent)  values(new.id,2,new.id_hypotesis);
  insert into ACL(GID,access_right, id_object)
    SELECT ACL.GID, ACL.ACCESS_RIGHT,new.id
    FROM ACL
    WHERE 
    (
      (ACL.ID_OBJECT = new.id_hypotesis)
    );
end
^

/* Trigger: PRAGMA_AU0 */
CREATE TRIGGER PRAGMA_AU0 FOR PRAGMA
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if((new.id<>old.id) or (new.id_hypotesis<>old.id_hypotesis) ) then
    update id_obj set id=new.id,id_parent=new.id_hypotesis where id=old.id;
end
^

/* Trigger: PRAGMA_BI */
CREATE TRIGGER PRAGMA_BI FOR PRAGMA
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: RB_DESCRIBER_BI */
CREATE TRIGGER RB_DESCRIBER_BI FOR RB_DESCRIBER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: TEMPORALITY_BI */
CREATE TRIGGER TEMPORALITY_BI FOR TEMPORALITY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_ID_ALL,1);
END
^

/* Trigger: TRG_USERS_BI0 */
CREATE TRIGGER TRG_USERS_BI0 FOR USERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    NEW.UID = GEN_ID(GEN_ID_ALL,1);
END
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE CALCULATE_RES_REMAINDER (
    ID_LINK INTEGER)
AS
declare variable tmp_id_parent integer;
declare variable id_lnk_forkedres integer;
declare variable tmp_hostid integer;
declare variable sum_expence float;
declare variable id_quantity integer;
declare variable id_remainder integer;
declare variable res_quantity float;
declare variable res_remainder float;
declare variable count_records integer;
begin
    
    /*Для работы процедуры получаем значения идентификаторов экстраатрибутов по их именам*/
    select ea_num_by_name.id_ea from ea_num_by_name('LNK_ForkedRES') into :id_lnk_forkedres;
    select ea_num_by_name.id_ea from ea_num_by_name('Quantity') into :id_quantity;
    select ea_num_by_name.id_ea from ea_num_by_name('Remainder') into :id_remainder;
    /*Получаем значение ресурса родителя для переданного в параметре идентификаторе копии ресурса*/
    SELECT t_LNK_ForkedRES.keyvalue
    FROM PRAGMA LEFT JOIN GET_EA_LIST_LNKP(:id_lnk_forkedres) t_LNK_ForkedRES ON (t_LNK_ForkedRES.id_link=PRAGMA.id)
    WHERE PRAGMA.id = :id_link into :tmp_ID_Parent;
    /*Обработке подвергается только родительский объект, для чего определяем значение его идентификатора*/
    if(:tmp_ID_Parent >0) then tmp_hostid=tmp_id_parent; else tmp_hostid=id_link;
    /*Находим количество ресурса родительского объекта*/
    SELECT t_Quantity.MEANING
    FROM PRAGMA
    LEFT JOIN GET_EA_LIST_NUM(:id_quantity) t_Quantity ON (t_Quantity.id_link=PRAGMA.id)
    WHERE PRAGMA.ID=:tmp_hostid
    INTO :res_quantity;
    /*Находим сумму истраченных ресурсов по родительскому идентификатору ресурса*/
    SELECT SUM(t_Quantity.MEANING)
    FROM PRAGMA
    LEFT JOIN GET_EA_LIST_LNKP(:id_lnk_forkedres) t_LNK_ForkedRES ON (t_LNK_ForkedRES.id_link=PRAGMA.id)
    LEFT JOIN GET_EA_LIST_NUM(:id_quantity) t_Quantity ON (t_Quantity.id_link=PRAGMA.id)
    GROUP BY t_LNK_ForkedRES.keyvalue
    HAVING t_LNK_ForkedRES.keyvalue = :tmp_hostid
    INTO :sum_expence;
    /*Вычисляем остаток*/
    res_remainder=res_quantity-sum_expence;
    /*Записываем значение остатка в экстраатрибут*/
    /* Далее взят кусок процедуры сохранения экстраатрибута и создан аналог вызова
    execute procedure set_ea_simple_num(:id_remainder,:tmp_hostid,:res_remainder,:date_of_change);
    поскольку непосредственный вызов производит deadlock*/
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_NUM.id_link) from EXTRAATTRIB_SIM_NUM
    where (EXTRAATTRIB_SIM_NUM.id_link=:tmp_hostid and EXTRAATTRIB_SIM_NUM.id_header=:id_remainder)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_NUM
            (EXTRAATTRIB_SIM_NUM.id_header,EXTRAATTRIB_SIM_NUM.id_link, EXTRAATTRIB_SIM_NUM."VALUE")
            values (:id_remainder,:tmp_hostid,:res_remainder);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_NUM set EXTRAATTRIB_SIM_NUM."VALUE"=:res_remainder
            where EXTRAATTRIB_SIM_NUM.id_header=:id_remainder and EXTRAATTRIB_SIM_NUM.id_link=:tmp_hostid;
        end
  --suspend;
end^


ALTER PROCEDURE DEL_ALL_EA_BYOBJID (
    ID_LINK INTEGER)
AS
begin
        /*Проходим последовательно по всем таблицам экстраатрибутов и удаляем все что находится по данному ID*/
        delete from extraatrib_rb where extraatrib_rb.id_link=:id_link;
        delete from extraattrib_dll where extraattrib_dll.id_link=:id_link;
        delete from extraattrib_sim_date where extraattrib_sim_date.id_link=:id_link;
        delete from extraattrib_sim_int where extraattrib_sim_int.id_link=:id_link;
        delete from extraattrib_sim_num where extraattrib_sim_num.id_link=:id_link;
        delete from extraattrib_sim_str where extraattrib_sim_str.id_link=:id_link;
        delete from extraattrib_lnk where extraattrib_lnk.id_link=:id_link;
        /*Проходим последовательно по всем таблицам экстраатрибутов и удаляем все что находится по данному ID, связанному с темпоральностью*/
        delete from extraatrib_rb where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_dll where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_date where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_int where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_num where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_sim_str where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        delete from extraattrib_lnk where id_link in (select temporality.id from  temporality where temporality.id_link=:id_link);
        /*Удаляем все ссылки привязаные к удаляемому объекту в самой таблице темпоральности*/
        delete from temporality where temporality.id_link=:id_link;
  suspend;
end^


ALTER PROCEDURE EA_NUM_BY_NAME (
    FIELDNAME VARCHAR(64))
RETURNS (
    ID_EA INTEGER)
AS
begin
  /* Procedure Text */
  select first 1 extraattrib_header.id from  extraattrib_header where UPPER(extraattrib_header.fieldname)=upper(:fieldname)
  into :id_ea;
  suspend;
end^


ALTER PROCEDURE GET_ACT_LIST_PRAGMA_HYP_EIDOS (
    ID_LINK2PRAGMAEIDOS INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    HYP_NAME VARCHAR(255),
    PRAGMA_DATE DATE,
    LINK2PRAGMA INTEGER)
AS
begin
  FOR
  SELECT p.ID, p.id_hypotesis, s.meaning ,d.meaning, i.meaning
    FROM pragma p
        left join get_ea_list_str(7064) s  on (p.id_hypotesis=s.id_link)
        left join get_ea_list_date(7262) d on (p.id_hypotesis=d.id_link)
        left join get_ea_list_int(7265) i on (p.id_hypotesis=i.id_link)
    WHERE i.meaning>0
  INTO
    :id,:id_hypotesis,:hyp_name,:pragma_date,:link2Pragma
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_EA_ALTCAPTIONS (
    ID_EIDOS INTEGER)
RETURNS (
    FIELD_NAME VARCHAR(64),
    NEWCAPTION VARCHAR(255))
AS
begin
      FOR
      SELECT EXTRAATTRIB_ALTCAPTION.fieldname,EXTRAATTRIB_ALTCAPTION.newcaption
      FROM EXTRAATTRIB_ALTCAPTION
      where EXTRAATTRIB_ALTCAPTION.id_eidos=:id_eidos
      INTO
        :field_name,:newcaption
      do
      begin 
          suspend;
      end
end^


ALTER PROCEDURE GET_EA_ATTRIBUTES_BYNUM (
    FIELDNUM INTEGER)
RETURNS (
    ID INTEGER,
    ID_CLASS INTEGER,
    FIELDNAME VARCHAR(64),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    LINKEDLEVELHP INTEGER,
    LINKEDOBJACT INTEGER,
    VISIBLE INTEGER,
    MULTILNK INTEGER)
AS
begin
  /* Procedure Text */
  select first 1
    extraattrib_header.id,
    extraattrib_header.id_class,
    extraattrib_header.fieldname,
    extraattrib_header.fieldtype,
    extraattrib_header.id_belongfor,
    extraattrib_header.id_rb_describer,
    extraattrib_header.dll_filename,
    extraattrib_header.dll_procname,
    extraattrib_header.temporality,
    extraattrib_header.required,
    extraattrib_header.linkedlevelhp,
    extraattrib_header.linkedobjact,
    extraattrib_header.visible,
    extraattrib_header.multilnk

    from  extraattrib_header
    where extraattrib_header.id=:fieldnum
  into
    :id,
    :id_class,
    :fieldname,
    :fieldtype,
    :id_belongfor,
    :id_rb_describer,
    :dll_filename,
    :dll_procname,
    :temporality,
    :required,
    :linkedlevelhp,
    :linkedobjact,
    :visible,
    :multilnk
    ;

  suspend;
end^


ALTER PROCEDURE GET_EA_LIST_DATE (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING TIMESTAMP,
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
     begin
     FOR
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_DATE."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_DATE
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_DATE.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_DATE.id_link,EXTRAATTRIB_SIM_DATE."VALUE"
        FROM EXTRAATTRIB_SIM_DATE
        WHERE 
          (
            (EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_DLL (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE VARCHAR(255))
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
    begin
     FOR
        SELECT s.ID_LINK, EXTRAATTRIB_DLL."VALUE",EXTRAATTRIB_DLL.keyvalue   --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_DLL
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_DLL.id_link)

        WHERE 
          (
            (EXTRAATTRIB_DLL.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_DLL.id_link,EXTRAATTRIB_DLL."VALUE",EXTRAATTRIB_DLL.keyvalue
        FROM EXTRAATTRIB_DLL
        WHERE 
          (
            (EXTRAATTRIB_DLL.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_INT (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
     begin
     FOR
        /*SELECT TEMPORALITY.ID_LINK, EXTRAATTRIB_SIM_INT."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_INT
            INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_INT.ID_LINK = TEMPORALITY.ID)
            INNER JOIN VW_LAST_SIMPLVALUE ON (TEMPORALITY.ID_LINK = VW_LAST_SIMPLVALUE.ID_LINK) AND (TEMPORALITY.DATE_TIME = VW_LAST_SIMPLVALUE.LAST_DATE)
        WHERE 
          (
            (EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
          )*/
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_INT."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_INT
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_INT.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_INT.id_link,EXTRAATTRIB_SIM_INT."VALUE"
        FROM EXTRAATTRIB_SIM_INT
        WHERE 
          (
            (EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_LNKH (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_MULTITABLE INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE HYPOTESISNAMEID INTEGER;
DECLARE VARIABLE IS_MULTILNK INTEGER;
begin
/*
Получаем необходимые значения для внутренних перемеенных
*/
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  SELECT EXTRAATTRIB_HEADER.multilnk FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_multilnk;

  if (:is_multilnk=1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
--Блок для темпоральных значений
  if(:is_temporality=1) then

    begin
     FOR
        SELECT s.ID_LINK, get_ea_list_str.meaning,EXTRAATTRIB_LNK.keyvalue,EXTRAATTRIB_LNK.ratio
            FROM EXTRAATTRIB_LNK
            left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_LNK.id_link)
        WHERE
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    do
        begin
            SUSPEND;
        end
   end

  else
--Блок простых значений
  begin
    FOR
        SELECT EXTRAATTRIB_LNK.id_link,get_ea_list_str.meaning,EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio
        FROM EXTRAATTRIB_LNK left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
        WHERE 
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_LNKP (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE HYPOTESISNAMEID INTEGER;
DECLARE VARIABLE PRAGMADATEID INTEGER;
DECLARE VARIABLE IS_MULTILNK INTEGER;
begin
/*
Получаем необходимые значения для внутренних перемеенных
*/
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  SELECT EXTRAATTRIB_HEADER.multilnk FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_multilnk;

  if (:is_multilnk=1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('PragmaDate') into :PRAGMADATEID;
--Блок для темпоральных значений
  if(:is_temporality=1) then

    begin
     FOR
        SELECT s.ID_LINK,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning),
                EXTRAATTRIB_LNK.keyvalue,
                EXTRAATTRIB_LNK.ratio

            FROM EXTRAATTRIB_LNK
            left join pragma on (EXTRAATTRIB_LNK.keyvalue=pragma.id)
            left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (pragma.id_hypotesis=hypName.id_link)
            left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (EXTRAATTRIB_LNK.keyvalue=PragmaDate.id_link)
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_LNK.id_link)
        WHERE
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    do
        begin
            SUSPEND;
        end
   end

  else
--Блок простых значений
  begin
    FOR
        SELECT EXTRAATTRIB_LNK.id_link,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning),
                EXTRAATTRIB_LNK.keyvalue,
                EXTRAATTRIB_LNK.ratio
        FROM EXTRAATTRIB_LNK
        left join pragma on (EXTRAATTRIB_LNK.keyvalue=pragma.id)
        left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (pragma.id_hypotesis=hypName.id_link)
        left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (EXTRAATTRIB_LNK.keyvalue=PragmaDate.id_link)
        WHERE 
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_MULTILNKH (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID INTEGER)
AS
DECLARE VARIABLE HYPOTESISNAMEID INTEGER;
DECLARE VARIABLE IS_MULTILNK INTEGER;
begin
/*
Получаем необходимые значения для внутренних перемеенных
*/
  SELECT EXTRAATTRIB_HEADER.multilnk FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_multilnk;

  if (:is_multilnk <> 1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, нельзя применять многозначные ссылки в видимых атрибутах

  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;

    begin
     FOR
        SELECT multiplexlnk.id_link, get_ea_list_str.meaning, EXTRAATTRIB_LNK.keyvalue,EXTRAATTRIB_LNK.ratio, multiplexlnk.id
            FROM EXTRAATTRIB_LNK
            left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
            INNER JOIN multiplexlnk ON (multiplexlnk.ID = EXTRAATTRIB_LNK.id_link)
        WHERE
          (
            (EXTRAATTRIB_LNK.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING,
             :keyvalue,
             :ratio,
             :id
    do
        begin
            SUSPEND;
        end
   end
end^


ALTER PROCEDURE GET_EA_LIST_NUM (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING FLOAT,
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
    begin
     FOR
        /*SELECT TEMPORALITY.ID_LINK, EXTRAATTRIB_SIM_NUM."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_NUM
            INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_NUM.ID_LINK = TEMPORALITY.ID)
            INNER JOIN VW_LAST_SIMPLVALUE ON (TEMPORALITY.ID_LINK = VW_LAST_SIMPLVALUE.ID_LINK) AND (TEMPORALITY.DATE_TIME = VW_LAST_SIMPLVALUE.LAST_DATE)
        WHERE 
          (
            (EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
          )*/
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_NUM."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_NUM
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_NUM.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_NUM.id_link,EXTRAATTRIB_SIM_NUM."VALUE"
        FROM EXTRAATTRIB_SIM_NUM
        WHERE 
          (
            (EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_LIST_RB (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER,
    KEYVALUE INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
WHERE (id = :id_ea_header) into :is_temporality;
if(:is_temporality=1) then
begin
FOR
SELECT s.ID_LINK, r.MEANING, r.id_value 
FROM GET_EA_RB(:id_ea_header) r
INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = r.id_link)
INTO :id_link,
:MEANING,
:keyvalue
do
begin
SUSPEND;
end
end
else
begin
FOR
SELECT GET_EA_RB.id_link,GET_EA_RB.MEANING,GET_EA_RB.id_value
FROM GET_EA_RB(:id_ea_header)
INTO :id_link,
:MEANING,
:keyvalue
DO
BEGIN
SUSPEND;
END
end
end^


ALTER PROCEDURE GET_EA_LIST_SECUR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING INTEGER,
    ID_LINK INTEGER)
AS
begin
  FOR
    SELECT VW_USER_OBIECTS.ID_OBJECT, VW_USER_OBIECTS.MAX_OF_ACCESS_RIGHT
    FROM VW_USER_OBIECTS
    INTO :id_link,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
end^


ALTER PROCEDURE GET_EA_LIST_STR (
    ID_EA_HEADER INTEGER)
RETURNS (
    MEANING VARCHAR(255),
    ID_LINK INTEGER)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
    begin
     FOR
        /*SELECT TEMPORALITY.ID_LINK, EXTRAATTRIB_SIM_STR."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_STR
            INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_STR.ID_LINK = TEMPORALITY.ID)
            INNER JOIN VW_LAST_SIMPLVALUE ON (TEMPORALITY.ID_LINK = VW_LAST_SIMPLVALUE.ID_LINK) AND (TEMPORALITY.DATE_TIME = VW_LAST_SIMPLVALUE.LAST_DATE)
        WHERE 
          (
            (EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
          )*/
        SELECT s.ID_LINK, EXTRAATTRIB_SIM_STR."VALUE"    --возвращаем ссылку на объект а не на темпоральный идентификатор
            FROM EXTRAATTRIB_SIM_STR
            INNER JOIN SP_GET_TEMPORALY_VALUE(:id_ea_header) s ON (s.ID = EXTRAATTRIB_SIM_STR.id_link)

        WHERE 
          (
            (EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    do
        begin
            SUSPEND;
        end
   end
  else
  begin
    FOR
        SELECT EXTRAATTRIB_SIM_STR.id_link,EXTRAATTRIB_SIM_STR."VALUE"
        FROM EXTRAATTRIB_SIM_STR
        WHERE 
          (
            (EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
          )
        INTO :id_link,
             :MEANING
    DO
    BEGIN
        SUSPEND;
    END
  end
end^


ALTER PROCEDURE GET_EA_NEWFIELDNAME
RETURNS (
    FLDNAME VARCHAR(64))
AS
begin
  --БСА
  --Берем значение генератора, приводим к типу varchar(20) и конкатенируем с префиксом
  fldname='Fld'||cast(gen_id(gen_ea_fldnum,1) as varchar(20));
  while (
        exists(
            select fieldname from extraattrib_header where fieldname=:fldname))
  do
    fldname='Fld'||cast(gen_id(gen_ea_fldnum,1) as varchar(20));
  suspend;
end^


ALTER PROCEDURE GET_EA_RB (
    ID_EA INTEGER)
RETURNS (
    ID_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    ID_RB INTEGER,
    ID_VALUE INTEGER)
AS
BEGIN
FOR
SELECT EXTRAATRIB_RB.ID_HEADER, EXTRAATRIB_RB.ID_LINK, EXTRAATRIB_RB."VALUE", EXTRAATRIB_RB.ID_RB
FROM EXTRAATRIB_RB
where (EXTRAATRIB_RB.ID_HEADER=:id_ea)
INTO :ID_HEADER,
:ID_LINK,
:ID_VALUE,
:ID_RB
DO
BEGIN
select meaning from get_rb(:ID_VALUE,:id_rb) into :meaning;
SUSPEND;
END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_DATE (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING TIMESTAMP)
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, EXTRAATTRIB_SIM_DATE."VALUE"
                FROM EXTRAATTRIB_SIM_DATE
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_DATE.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_SIM_DATE.id_header=:id_header
    INTO    :id,
        :DATE_TIME,
        :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_DLL (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, extraattrib_dll."VALUE"
                FROM extraattrib_dll
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_DLL.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_DLL.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_INT (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING INTEGER)
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, EXTRAATTRIB_SIM_INT."VALUE"
                FROM EXTRAATTRIB_SIM_INT
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_SIM_INT.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link  and  EXTRAATTRIB_SIM_INT.id_header=:id_header
    INTO :ID, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_LNKH (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
declare variable hypotesisnameid integer;
BEGIN
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, get_ea_list_str.meaning, EXTRAATTRIB_LNK.ratio
                FROM EXTRAATTRIB_LNK
                left join get_ea_list_str(:HYPOTESISNAMEID) on (EXTRAATTRIB_LNK.keyvalue=get_ea_list_str.id_link)
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_LNK.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_LNK.id_header=:id_header
    INTO :id,
         :DATE_TIME,
         :meaning,
         :ratio
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_LNKP (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255),
    RATIO FLOAT)
AS
declare variable hypotesisnameid integer;
declare variable pragmadateid integer;
BEGIN
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('PragmaDate') into :PRAGMADATEID;

  FOR
    SELECT TEMPORALITY.id, TEMPORALITY.date_time,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning),
                EXTRAATTRIB_LNK.ratio
                FROM EXTRAATTRIB_LNK
                left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (EXTRAATTRIB_LNK.keyvalue=hypName.id_link)
                left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (EXTRAATTRIB_LNK.keyvalue=PragmaDate.id_link)
                INNER JOIN TEMPORALITY ON (EXTRAATTRIB_LNK.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link and  EXTRAATTRIB_LNK.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning,
         :ratio
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_NUM (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING FLOAT)
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id ,TEMPORALITY.date_time, extraattrib_sim_num."VALUE"
                FROM extraattrib_sim_num
                INNER JOIN TEMPORALITY ON (extraattrib_sim_num.id_link = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link  and  extraattrib_sim_num.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_RB (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id,TEMPORALITY.date_time, r.meaning
                FROM GET_EA_RB(:id_header) r
                INNER JOIN TEMPORALITY ON (r.ID_LINK = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EA_TEMP_LIST_STR (
    ID_LINK INTEGER,
    ID_HEADER INTEGER)
RETURNS (
    ID INTEGER,
    DATE_TIME TIMESTAMP,
    MEANING VARCHAR(255))
AS
BEGIN
  FOR
    SELECT TEMPORALITY.id,TEMPORALITY.date_time, extraattrib_sim_str."VALUE"
                FROM extraattrib_sim_str
                INNER JOIN TEMPORALITY ON (extraattrib_sim_str.id_link = TEMPORALITY.ID)
    where TEMPORALITY.ID_LINK=:id_link  and  extraattrib_sim_str.id_header=:id_header
    INTO :id, :DATE_TIME,
         :meaning
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE GET_EIDOS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
AS
begin
  /* Procedure Text */
  FOR
  select first 1  EIDOS.id ,EIDOS.id_parent, EIDOS.name,EIDOS.species
  from EIDOS
  where (EIDOS.id =:id_in)
  into :id, :id_parent, :name, :species
  do 
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_EIDOS_LIST (
    EIDOS_SPEC VARCHAR(64))
RETURNS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255))
AS
begin
if(:eidos_spec='ALL' ) then
    begin
      FOR
      SELECT eidos.id, eidos.id_parent,eidos.name
      FROM eidos
      order by eidos."LEVEL",eidos.id_parent,eidos.id  ascending
      INTO
        :id,:id_parent,:name
      do
      begin 
      suspend;
      end
    end
else
    begin
      FOR
      SELECT eidos.id, eidos.id_parent,eidos.name
      FROM eidos
      WHERE eidos.species=:eidos_spec
      order by eidos."LEVEL",eidos.id_parent,eidos.id  ascending
      INTO
        :id,:id_parent,:name
      do
      begin 
      suspend;
      end
    end
end^


ALTER PROCEDURE GET_EIDOSEXTRAATTRIB_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    NAMESTOREDPROC VARCHAR(64),
    TEMPORALLISTSPNAME VARCHAR(64),
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
AS
begin
    if (:id_eidos >0) then
    begin
      FOR
      select
        EXTRAATTRIB_HEADER.id,
        EXTRAATTRIB_HEADER.caption,
        EXTRAATTRIB_HEADER.fieldtype,
        EXTRAATTRIB_HEADER.id_belongfor,
        EXTRAATTRIB_HEADER.id_rb_describer,
        EXTRAATTRIB_HEADER.dll_filename,
        EXTRAATTRIB_HEADER.dll_procname,
        EXTRAATTRIB_HEADER.fieldname,
        EXTRAATTRIB_HEADER.temporality,
        EXTRAATTRIB_HEADER.required,
        EXTRAATTRIB_HEADER.visible,
        EXTRAATTRIB_HEADER.locked,
        extraattrib_support.namestoredproc,
        extraattrib_support.temporallistspname,
        EXTRAATTRIB_HEADER.multilnk,
        EXTRAATTRIB_HEADER.lnk_species,
        EXTRAATTRIB_HEADER.lnk_eidosid,
        EXTRAATTRIB_HEADER.lnk_hypid,
        EXTRAATTRIB_HEADER.lnk_needlist


      from EXTRAATTRIB_HEADER inner join extraattrib_support on  (EXTRAATTRIB_HEADER.fieldtype=extraattrib_support.fieldtype)
      where (EXTRAATTRIB_HEADER.id_CLASS =:id_EIDOS )
      into
        :id,
        :caption,
        :fieldtype,
        :id_belongfor,
        :id_rb_describer,
        :dll_filename,
        :dll_procname,
        :fieldname,
        :temporality,
        :required,
        :visible,
        :locked,
        :namestoredproc,
        :temporallistspname,
        :multilnk,
        :lnk_species,
        :lnk_eidosid,
        :lnk_hypid,
        :lnk_needlist
      do
      begin 
      suspend;
      end
    end
else
    begin
      FOR
      select
        EXTRAATTRIB_HEADER.id,
        EXTRAATTRIB_HEADER.caption,
        EXTRAATTRIB_HEADER.fieldtype,
        EXTRAATTRIB_HEADER.id_belongfor,
        EXTRAATTRIB_HEADER.id_rb_describer,
        EXTRAATTRIB_HEADER.dll_filename,
        EXTRAATTRIB_HEADER.dll_procname,
        EXTRAATTRIB_HEADER.fieldname,
        EXTRAATTRIB_HEADER.temporality,
        EXTRAATTRIB_HEADER.required,
        EXTRAATTRIB_HEADER.visible,
        EXTRAATTRIB_HEADER.locked,
        extraattrib_support.namestoredproc,
        extraattrib_support.temporallistspname,
        EXTRAATTRIB_HEADER.multilnk,
        EXTRAATTRIB_HEADER.lnk_species,
        EXTRAATTRIB_HEADER.lnk_eidosid,
        EXTRAATTRIB_HEADER.lnk_hypid,
        EXTRAATTRIB_HEADER.lnk_needlist

      from EXTRAATTRIB_HEADER inner join extraattrib_support on  (EXTRAATTRIB_HEADER.fieldtype=extraattrib_support.fieldtype)
      into
        :id,
        :caption,
        :fieldtype,
        :id_belongfor,
        :id_rb_describer,
        :dll_filename,
        :dll_procname,
        :fieldname,
        :temporality,
        :required,
        :visible,
        :locked,
        :namestoredproc,
        :temporallistspname,
        :multilnk,
        :lnk_species,
        :lnk_eidosid,
        :lnk_hypid,
        :lnk_needlist

      do
      begin 
      suspend;
      end
    end
end^


ALTER PROCEDURE GET_HYPOTESIS (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER)
AS
begin
  /* Procedure Text */
  FOR
  select first 1  HYPOTESIS.id ,HYPOTESIS.id_eidos
  from HYPOTESIS
  where (HYPOTESIS.id =:id_in)
  into :id, :id_eidos
  do 
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_HYPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER)
AS
begin
  FOR
  SELECT
        HYPOTESIS.ID
  FROM HYPOTESIS
  WHERE HYPOTESIS.id_EIDOS=:id_eidos
  INTO
    :id
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_HYPOTESIS_NAME_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
declare variable hypotesisnameid integer;
begin
     select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
  SELECT HYPOTESIS.ID, hypName.meaning
    FROM HYPOTESIS
      left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (HYPOTESIS.id=hypName.id_link)
      WHERE HYPOTESIS.id_EIDOS=:id_eidos
  INTO
    :id,:meaning
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_ID_TOPSPECIES (
    SPECIES VARCHAR(64))
RETURNS (
    ID_TOP_SPECIES INTEGER)
AS
begin
  select first 1 eidos.id from  eidos
      where UPPER(eidos.species)=upper(:species) and eidos.id_parent<=1
  into :id_top_species;
  suspend;
end^


ALTER PROCEDURE GET_LINKED_HYPLIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
declare variable dt timestamp;
declare variable is_temporal integer;
declare variable is_multilink integer;
declare variable keyvalue integer;
declare variable id_link integer;
declare variable temp_id_link integer;
declare variable temp_realid_link integer;
BEGIN
  --Получаем значение программного времени с которым производится сравнение
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  --Извлекаем значения любой из ссылок на указанный объект--
  FOR
  select
        extraattrib_lnk.id_link,
        extraattrib_lnk.id_header,
        extraattrib_lnk.ratio
  from  extraattrib_lnk
  where extraattrib_lnk.keyvalue=:id_item
  into
    :id_link,
    :id_header,
    :ratio
  DO
      BEGIN
        select first 1 extraattrib_header.temporality,extraattrib_header.multilnk
          from extraattrib_header where extraattrib_header.id=:id_header
          into :is_temporal, :is_multilink;

        id_hypotesis=0;
        id_eidos=0;

        if (is_temporal=0 and is_multilink=0) then    --Значение - прямая одиночная ссылка
            begin
                select first 1 hypotesis.id,hypotesis.id_eidos
                    from hypotesis where hypotesis.id=:id_link into :id_hypotesis, :id_eidos;
            end
        else
            begin
            if (is_temporal<>0) then    --Значение темпоральное
                begin
                select first 1 temporality.id, temporality.id_link
                    from temporality
                    where temporality.id_header=:id_header and temporality.date_time<=:dt
                    order by temporality.date_time desc
                into :temp_id_link, :temp_realid_link;
                if(temp_id_link=id_link) then   --Значение текущего значения в темпоральной таблице соответствует
                    begin
                        select first 1 hypotesis.id,hypotesis.id_eidos
                            from hypotesis where hypotesis.id=:temp_realid_link into :id_hypotesis, :id_eidos;
                    end
                end
            if (is_multilink<>0) then    --Значение мультилинк
                begin
                    select first 1 multiplexlnk.id, multiplexlnk.id_link
                        from multiplexlnk
                        where multiplexlnk.id=:id_link
                        into :temp_id_link, :temp_realid_link;
                    select first 1 hypotesis.id,hypotesis.id_eidos
                        from hypotesis where hypotesis.id=:temp_realid_link into :id_hypotesis, :id_eidos;
                end
            end
        if (id_hypotesis>0 and id_eidos>0) then SUSPEND;
      END
END^


ALTER PROCEDURE GET_LINKED_PRAGMALIST (
    ID_ITEM INTEGER)
RETURNS (
    ID_EIDOS INTEGER,
    ID_PRAGMA INTEGER,
    ID_HEADER INTEGER,
    RATIO INTEGER)
AS
declare variable dt timestamp;
declare variable is_temporal integer;
declare variable is_multilink integer;
declare variable keyvalue integer;
declare variable id_link integer;
declare variable temp_id_link integer;
declare variable temp_realid_link integer;
BEGIN
  --Получаем значение программного времени с которым производится сравнение
  select var_dt.dt from var_dt where var_dt.user_name=user into :dt;
  --Извлекаем значения любой из ссылок на указанный объект--
  FOR
  select
        extraattrib_lnk.id_link,
        extraattrib_lnk.id_header,
        extraattrib_lnk.ratio
  from  extraattrib_lnk
  where extraattrib_lnk.keyvalue=:id_item
  into
    :id_link,
    :id_header,
    :ratio
  DO
      BEGIN
        select first 1 extraattrib_header.temporality,extraattrib_header.multilnk
          from extraattrib_header where extraattrib_header.id=:id_header
          into :is_temporal, :is_multilink;

        id_pragma=0;
        id_eidos=0;

        if (is_temporal=0 and is_multilink=0) then    --Значение - прямая одиночная ссылка
            begin
                select first 1 pragma.id,pragma.id_eidos
                    from pragma where pragma.id=:id_link into :id_pragma, :id_eidos;
            end
        else
            begin
            if (is_temporal<>0) then    --Значение темпоральное
                begin
                select first 1 temporality.id, temporality.id_link
                    from temporality
                    where temporality.id_header=:id_header and temporality.date_time<=:dt
                    order by temporality.date_time desc
                into :temp_id_link, :temp_realid_link;
                if(temp_id_link=id_link) then   --Значение текущего значения в темпоральной таблице соответствует
                    begin
                        select first 1 pragma.id,pragma.id_eidos
                            from pragma where pragma.id=:temp_realid_link into :id_pragma, :id_eidos;
                    end
                end
            if (is_multilink<>0) then    --Значение мультилинк
                begin
                    select first 1 multiplexlnk.id, multiplexlnk.id_link
                        from multiplexlnk
                        where multiplexlnk.id=:id_link
                        into :temp_id_link, :temp_realid_link;
                    select first 1 pragma.id,pragma.id_eidos
                        from pragma where pragma.id=:temp_realid_link into :id_pragma, :id_eidos;
                end
            end
        if (id_pragma>0 and id_eidos>0) then SUSPEND;
      END
END^


ALTER PROCEDURE GET_PRAGMA (
    ID_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
AS
begin
  /* Procedure Text */
  FOR
  select first 1  PRAGMA.id, PRAGMA.id_eidos, PRAGMA.id_hypotesis
  from PRAGMA
  where (PRAGMA.id =:id_in)
  into :id, :id_eidos, :id_hypotesis
  do 
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_PRAGMA_LIST (
    ID_EIDOS INTEGER,
    ID_HYP_IN INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER)
AS
begin
  FOR
  SELECT PRAGMA.ID,PRAGMA.id_hypotesis
    FROM pragma
    WHERE (PRAGMA.ID_HYPOTESIS=:id_hyp_in AND PRAGMA.id_eidos=:id_eidos)
  INTO
    :id, :id_hypotesis
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_PRAGMA_NAME_LIST
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    MEANING VARCHAR(255))
AS
DECLARE VARIABLE PRAGMADATEID INTEGER;
DECLARE VARIABLE HYPOTESISNAMEID INTEGER;
begin
   select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('PragmaDate') into :PRAGMADATEID;
     select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
  SELECT PRAGMA.ID,PRAGMA.id_hypotesis,
                hypName.meaning||' от '||
                extract (day from PragmaDate.meaning)||'.'||
                extract (month from PragmaDate.meaning)||'.'||
                extract (year from PragmaDate.meaning)
    FROM pragma
      left join get_ea_list_str(:HYPOTESISNAMEID) hypName on (pragma.id_hypotesis=hypName.id_link)
      left join get_ea_list_date(:PRAGMADATEID) PragmaDate on (PRAGMA.ID=PragmaDate.id_link)
   -- WHERE (PRAGMA.ID_HYPOTESIS=:id_hyp_in AND PRAGMA.id_eidos=:id_eidos)
  INTO
    :id, :id_hypotesis,:meaning
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_PRAGMA_WITH_HIPOTESIS_LIST (
    ID_EIDOS INTEGER)
RETURNS (
    ID INTEGER,
    ID_HYPOTESIS INTEGER,
    HYP_NAME VARCHAR(255))
AS
DECLARE VARIABLE HYPOTESISNAMEID INTEGER;
begin
  select EA_NUM_BY_NAME.id_ea from  EA_NUM_BY_NAME('HypName') into :HYPOTESISNAMEID;
  FOR
  SELECT PRAGMA.ID, PRAGMA.id_hypotesis, get_ea_list_str.meaning
    FROM pragma left join get_ea_list_str(:HYPOTESISNAMEID) on (PRAGMA.id_hypotesis=get_ea_list_str.id_link)
    WHERE PRAGMA.id_eidos=:id_eidos
  INTO
    :id,:id_hypotesis,:hyp_name
  do
  begin 
  suspend;
  end
end^


ALTER PROCEDURE GET_RB (
    ID_VALUE INTEGER,
    ID_RB INTEGER)
RETURNS (
    ID INTEGER,
    MEANING VARCHAR(255))
AS
DECLARE VARIABLE SQL VARCHAR(255);
begin
  select sqlstring from rb_describer where id=:id_rb into :sql;
  sql=sql||' where id='||cast(:id_value as varchar(24));
  for EXECUTE STATEMENT sql INTO :id, :meaning
  do
  suspend;
end^


ALTER PROCEDURE SET_EA_DLL (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    KEYVALUE VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE IS_TEMPORALITY SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            id=GEN_ID(GEN_ID_ALL,1);   --получим идентификатор для id_link
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
           -- select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            --into :id_link;
            id_link=:id;                        --Здесь уже id_link
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_DLL
            (EXTRAATTRIB_DLL.id_header,EXTRAATTRIB_DLL.id_link, EXTRAATTRIB_DLL."VALUE", EXTRAATTRIB_DLL.keyvalue)
            values (:id_ea_header,:id_link,:meaning,:keyvalue);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение, найдем его линк
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            --и обновим
            update EXTRAATTRIB_DLL set EXTRAATTRIB_DLL."VALUE"=:meaning, EXTRAATTRIB_DLL.keyvalue=:keyvalue
            where EXTRAATTRIB_DLL.id_header=:id_ea_header and EXTRAATTRIB_DLL.id_link=:id_link;
        end
   end
  else
   begin
      /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_DLL.id_link) from EXTRAATTRIB_DLL
    where (EXTRAATTRIB_DLL.id_link=:id_link and EXTRAATTRIB_DLL.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_DLL
            (EXTRAATTRIB_DLL.id_header,EXTRAATTRIB_DLL.id_link, EXTRAATTRIB_DLL."VALUE", EXTRAATTRIB_DLL.keyvalue)
            values (:id_ea_header,:id_link,:meaning,:keyvalue);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_DLL set EXTRAATTRIB_DLL."VALUE"=:meaning, EXTRAATTRIB_DLL.keyvalue=:keyvalue
            where EXTRAATTRIB_DLL.id_header=:id_ea_header and EXTRAATTRIB_DLL.id_link=:id_link;
        end
   end
end^


ALTER PROCEDURE SET_EA_LNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
declare variable count_records smallint;
declare variable is_temporality smallint;
declare variable id integer;
declare variable kind_link integer;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY, EXTRAATTRIB_HEADER.fieldtype FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality,:kind_link;
  /*Определяем валидность переданной в параметре ссылке*/
  if(:kind_link=103) then --103 - ссылка на hipotesys
    begin
        select count(hypotesis.id) from hypotesis where hypotesis.id=:keyvalue into :count_records;
        if (:count_records<1) then  exception NEVER_PARAMS_VALUES;
    end
   else --104 - ссылка на pragma
    begin
        select count(pragma.id) from pragma where pragma.id=:keyvalue into :count_records;
        if (:count_records<1) then  exception NEVER_PARAMS_VALUES;
    end

  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            id=GEN_ID(GEN_ID_ALL,1);   --получим идентификатор для id_link
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
           -- select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            --into :id_link;
            id_link=:id;                        --Здесь уже id_link
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_LNK
            (EXTRAATTRIB_LNK.id_header,EXTRAATTRIB_LNK.id_link, EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio)
            values (:id_ea_header,:id_link,:keyvalue, :ratio);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение, найдем его линк
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            --и обновим
            update EXTRAATTRIB_LNK set EXTRAATTRIB_LNK.keyvalue=:keyvalue, EXTRAATTRIB_LNK.ratio=:ratio
            where EXTRAATTRIB_LNK.id_header=:id_ea_header and EXTRAATTRIB_LNK.id_link=:id_link;
        end
   end
  else
   begin
      /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_LNK.id_link) from EXTRAATTRIB_LNK
    where (EXTRAATTRIB_LNK.id_link=:id_link and EXTRAATTRIB_LNK.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_LNK
            (EXTRAATTRIB_LNK.id_header,EXTRAATTRIB_LNK.id_link, EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio)
            values (:id_ea_header,:id_link,:keyvalue, :ratio);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_LNK set EXTRAATTRIB_LNK.keyvalue=:keyvalue, EXTRAATTRIB_LNK.ratio=:ratio
            where EXTRAATTRIB_LNK.id_header=:id_ea_header and EXTRAATTRIB_LNK.id_link=:id_link;
        end
   end
end^


ALTER PROCEDURE SET_EA_MULTILNK (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    KEYVALUE INTEGER,
    RATIO FLOAT,
    ID_INLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
DECLARE VARIABLE ID INTEGER;
begin
  begin
  if(:id_inlist <= 0) then  /*Это новая запись, необходимо добавление*/
        begin
            id=GEN_ID(GEN_ID_ALL,1);   --получим идентификатор для id_link
            insert into MULTIPLEXLNK(id,id_link, id_header) values (:id,:id_link,:id_ea_header);
            insert into EXTRAATTRIB_LNK
            (EXTRAATTRIB_LNK.id_header,EXTRAATTRIB_LNK.id_link, EXTRAATTRIB_LNK.keyvalue, EXTRAATTRIB_LNK.ratio)
            values (:id_ea_header,:id,:keyvalue, :ratio);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим само значение, найдем его линк
            select id from MULTIPLEXLNK where MULTIPLEXLNK.id_link=:id_link and MULTIPLEXLNK.id=:id_inlist and MULTIPLEXLNK.id_header=:id_ea_header
            into :id;

            update EXTRAATTRIB_LNK set EXTRAATTRIB_LNK.keyvalue=:keyvalue, EXTRAATTRIB_LNK.ratio=:ratio
            where EXTRAATTRIB_LNK.id_header=:id_ea_header and EXTRAATTRIB_LNK.id_link=:id;
        end
   end
   id_out=id;
end^


ALTER PROCEDURE SET_EA_RB (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    ID_RB INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE COUNT_RECORDS INTEGER;
DECLARE VARIABLE IS_TEMPORALITY SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
if(:id_rb=0 and :meaning=0) then --удаление
    delete from extraatrib_rb where (extraatrib_rb.id_header=:id_ea_header and extraatrib_rb.id_link=:id_link);
else
 begin
   SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
    WHERE (id = :id_ea_header) into :is_temporality;
   if(:is_temporality=1) then
    begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
      select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
      if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
             --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into extraatrib_rb
            (extraatrib_rb.id_header,extraatrib_rb.id_link, extraatrib_rb."VALUE", extraatrib_rb.id_rb)
            values (:id_ea_header,:id_link,:meaning,:id_rb);
        end
      else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update extraatrib_rb set extraatrib_rb."VALUE"=:meaning, extraatrib_rb.id_rb=:id_rb
            where extraatrib_rb.id_header=:id_ea_header and extraatrib_rb.id_link=:id_link;
        end
     end
    else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
      select count(extraatrib_rb.id_link) from extraatrib_rb
      where (extraatrib_rb.id_link=:id_link and extraatrib_rb.id_header=:id_ea_header)
      into :COUNT_RECORDS;
      if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin

            insert into extraatrib_rb
            (extraatrib_rb.id_header,extraatrib_rb.id_link, extraatrib_rb."VALUE", extraatrib_rb.id_rb)
            values (:id_ea_header,:id_link,:meaning,:id_rb);
        end
      else    /*Запись уже существует - обновление*/
        begin
            update extraatrib_rb set extraatrib_rb."VALUE"=:meaning, extraatrib_rb.id_rb=:id_rb
            where extraatrib_rb.id_header=:id_ea_header and extraatrib_rb.id_link=:id_link;
        end
    end
  end
end^


ALTER PROCEDURE SET_EA_SIMPLE_DATE (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING TIMESTAMP,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_DATE
            (EXTRAATTRIB_SIM_DATE.id_header,EXTRAATTRIB_SIM_DATE.id_link, EXTRAATTRIB_SIM_DATE."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_DATE set EXTRAATTRIB_SIM_DATE."VALUE"=:meaning
            where EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header and EXTRAATTRIB_SIM_DATE.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_DATE.id_link) from EXTRAATTRIB_SIM_DATE
    where (EXTRAATTRIB_SIM_DATE.id_link=:id_link and EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_DATE
            (EXTRAATTRIB_SIM_DATE.id_header,EXTRAATTRIB_SIM_DATE.id_link, EXTRAATTRIB_SIM_DATE."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_DATE set EXTRAATTRIB_SIM_DATE."VALUE"=:meaning
            where EXTRAATTRIB_SIM_DATE.id_header=:id_ea_header and EXTRAATTRIB_SIM_DATE.id_link=:id_link;
        end
  end
end^


ALTER PROCEDURE SET_EA_SIMPLE_INT (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING INTEGER,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id,id_link, date_time,ID_HEADER) values (:id,:id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_INT
            (EXTRAATTRIB_SIM_INT.id_header,EXTRAATTRIB_SIM_INT.id_link, EXTRAATTRIB_SIM_INT."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_INT set EXTRAATTRIB_SIM_INT."VALUE"=:meaning
            where EXTRAATTRIB_SIM_INT.id_header=:id_ea_header and EXTRAATTRIB_SIM_INT.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_INT.id_link) from EXTRAATTRIB_SIM_INT
    where (EXTRAATTRIB_SIM_INT.id_link=:id_link and EXTRAATTRIB_SIM_INT.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_INT
            (EXTRAATTRIB_SIM_INT.id_header,EXTRAATTRIB_SIM_INT.id_link, EXTRAATTRIB_SIM_INT."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_INT set EXTRAATTRIB_SIM_INT."VALUE"=:meaning
            where EXTRAATTRIB_SIM_INT.id_header=:id_ea_header and EXTRAATTRIB_SIM_INT.id_link=:id_link;
        end
  end
end^


ALTER PROCEDURE SET_EA_SIMPLE_NUM (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING FLOAT,
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
DECLARE VARIABLE QUANTITY_ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id, id_link, date_time,ID_HEADER) values (:id, :id_link,:date_of_change,:id_ea_header);
            id_link=:id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_NUM
            (EXTRAATTRIB_SIM_NUM.id_header,EXTRAATTRIB_SIM_NUM.id_link, EXTRAATTRIB_SIM_NUM."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_NUM set EXTRAATTRIB_SIM_NUM."VALUE"=:meaning
            where EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header and EXTRAATTRIB_SIM_NUM.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_NUM.id_link) from EXTRAATTRIB_SIM_NUM
    where (EXTRAATTRIB_SIM_NUM.id_link=:id_link and EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_NUM
            (EXTRAATTRIB_SIM_NUM.id_header,EXTRAATTRIB_SIM_NUM.id_link, EXTRAATTRIB_SIM_NUM."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_NUM set EXTRAATTRIB_SIM_NUM."VALUE"=:meaning
            where EXTRAATTRIB_SIM_NUM.id_header=:id_ea_header and EXTRAATTRIB_SIM_NUM.id_link=:id_link;
        end
  end
  /*Проверяем не является ли атрибут значением Quantity для ветки RES*/
  select ea_num_by_name.id_ea from ea_num_by_name('Quantity') into :quantity_id;
  if(:quantity_id=:id_ea_header) then execute procedure Calculate_Res_Remainder(:id_link);
end^


ALTER PROCEDURE SET_EA_SIMPLE_STR (
    ID_EA_HEADER INTEGER,
    ID_LINK INTEGER,
    MEANING VARCHAR(255),
    DATE_OF_CHANGE TIMESTAMP)
AS
DECLARE VARIABLE IS_TEMPORALITY INTEGER;
DECLARE VARIABLE COUNT_RECORDS SMALLINT;
DECLARE VARIABLE ID INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.TEMPORALITY FROM EXTRAATTRIB_HEADER
  WHERE (id = :id_ea_header) into :is_temporality;
  if(:is_temporality=1) then
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(temporality.id_link) from temporality
    where (temporality.id_link=:id_link and temporality.id_header=:id_ea_header and temporality.date_time=:date_of_change)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            --добавляем в temporality и получаем id_link
            ID = GEN_ID(GEN_ID_ALL,1);
            insert into temporality(id, id_link, date_time,ID_HEADER) values (:id, :id_link,:date_of_change,:id_ea_header);
            id_link = :id;
            --добавляем непосредственно значение
            insert into EXTRAATTRIB_SIM_STR
            (EXTRAATTRIB_SIM_STR.id_header,EXTRAATTRIB_SIM_STR.id_link, EXTRAATTRIB_SIM_STR."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            --обновим дату значения
            update temporality set date_time=:date_of_change where id=:id_link;
            --обновим само значение
            select id from temporality where id_link=:id_link and date_time=:date_of_change and ID_HEADER=:id_ea_header
            into :id_link;
            update EXTRAATTRIB_SIM_STR set EXTRAATTRIB_SIM_STR."VALUE"=:meaning
            where EXTRAATTRIB_SIM_STR.id_header=:id_ea_header and EXTRAATTRIB_SIM_STR.id_link=:id_link;
        end
  end
 else
   begin
    /*Определяем есть ли запись в таблице или ее необходимо добавлять*/
    select count(EXTRAATTRIB_SIM_STR.id_link) from EXTRAATTRIB_SIM_STR
    where (EXTRAATTRIB_SIM_STR.id_link=:id_link and EXTRAATTRIB_SIM_STR.id_header=:id_ea_header)
    into :COUNT_RECORDS;
    if(:COUNT_RECORDS<1) then     /*Для случая новой записи*/
        begin
            insert into EXTRAATTRIB_SIM_STR
            (EXTRAATTRIB_SIM_STR.id_header,EXTRAATTRIB_SIM_STR.id_link, EXTRAATTRIB_SIM_STR."VALUE")
            values (:id_ea_header,:id_link,:meaning);
        end
    else    /*Запись уже существует - обновление*/
        begin
            update EXTRAATTRIB_SIM_STR set EXTRAATTRIB_SIM_STR."VALUE"=:meaning
            where EXTRAATTRIB_SIM_STR.id_header=:id_ea_header and EXTRAATTRIB_SIM_STR.id_link=:id_link;
        end
  end
end^


ALTER PROCEDURE SET_EIDOS (
    ID INTEGER,
    ID_PARENT INTEGER,
    NAME VARCHAR(255),
    SPECIES VARCHAR(64))
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:ID<1) then
        begin
            id_out=GEN_ID(GEN_ID_ALL,1);
            insert into EIDOS (eidos.id,EIDOS.id_parent ,EIDOS.name,EIDOS.species) values (:id_out,:id_parent ,:name,:species );
            --select id from EIDOS where (EIDOS.id_parent =:id_parent and EIDOS.name =:name and EIDOS.species=:species)  into :id_out ;
        end
    else
        begin
            update EIDOS set EIDOS.id_parent=:id_parent, EIDOS.name=:name, EIDOS.species=:species where id=:id ;
            --select id from EIDOS where EIDOS.id =:id   into :id_out ; --совершенно лишнее, id ведь не изменился
            id_out=:id;
        end
end^


ALTER PROCEDURE SET_EIDOSEXTRAATTRIB (
    ID INTEGER,
    ID_EIDOS INTEGER,
    CAPTION VARCHAR(255),
    FIELDTYPE INTEGER,
    ID_BELONGFOR INTEGER,
    ID_RB_DESCRIBER INTEGER,
    DLL_FILENAME VARCHAR(64),
    DLL_PROCNAME VARCHAR(64),
    FIELDNAME VARCHAR(64),
    TEMPORALITY INTEGER,
    REQUIRED INTEGER,
    VISIBLE INTEGER,
    LOCKED INTEGER,
    MULTILNK INTEGER,
    LNK_SPECIES VARCHAR(64),
    LNK_EIDOSID INTEGER,
    LNK_HYPID INTEGER,
    LNK_NEEDLIST INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:temporality=1 and :multilnk=1) then  exception NEVER_PARAMS_VALUES;--Ошибка конфигурации экстраатрибута, одновременно и многозначным и темпоральным он быть не может

    if (:ID<1) then
        begin
        id_out=GEN_ID(GEN_ID_ALL,1);
        insert into EXTRAATTRIB_HEADER
            (extraattrib_header.id,
            EXTRAATTRIB_HEADER.id_class,
            EXTRAATTRIB_HEADER.caption,
            EXTRAATTRIB_HEADER.fieldtype,
            EXTRAATTRIB_HEADER.id_belongfor,
            EXTRAATTRIB_HEADER.id_rb_describer,
            EXTRAATTRIB_HEADER.dll_filename,
            EXTRAATTRIB_HEADER.dll_procname,
            EXTRAATTRIB_HEADER.fieldname,
            EXTRAATTRIB_HEADER.temporality,
            EXTRAATTRIB_HEADER.required,
            EXTRAATTRIB_HEADER.visible,
            EXTRAATTRIB_HEADER.locked,
            EXTRAATTRIB_HEADER.multilnk,
            EXTRAATTRIB_HEADER.lnk_species,
            EXTRAATTRIB_HEADER.lnk_eidosid,
            EXTRAATTRIB_HEADER.lnk_hypid,
            EXTRAATTRIB_HEADER.lnk_needlist

            )
            values (:id_out,:id_EIDOS,:caption,:fieldtype,:id_belongfor,:id_rb_describer,:dll_filename,:dll_procname,:fieldname,:temporality,:required,
            :visible,:locked,:multilnk,:lnk_species,:lnk_eidosid,:lnk_hypid,:lnk_needlist);
            --select max(id) from EXTRAATTRIB_HEADER where (EXTRAATTRIB_HEADER.id_class=:id_eidos and EXTRAATTRIB_HEADER.caption=:caption and EXTRAATTRIB_HEADER.fieldtype=:fieldtype and EXTRAATTRIB_HEADER.id_belongfor=:id_belongfor) into :id_out;
            --последний запрос в корне неверный при многопользовательской работе
        end
    else
        begin
            update EXTRAATTRIB_HEADER set
                    EXTRAATTRIB_HEADER.id =:id,
                    EXTRAATTRIB_HEADER.id_class=:id_EIDOS,
                    EXTRAATTRIB_HEADER.caption=:caption,
                    EXTRAATTRIB_HEADER.fieldtype=:fieldtype,
                    EXTRAATTRIB_HEADER.id_belongfor=:id_belongfor,
                    EXTRAATTRIB_HEADER.id_rb_describer=:id_rb_describer,
                    EXTRAATTRIB_HEADER.dll_filename=:dll_filename,
                    EXTRAATTRIB_HEADER.dll_procname=:dll_procname,
                    EXTRAATTRIB_HEADER.fieldname=:fieldname,
                    EXTRAATTRIB_HEADER.temporality=:temporality,
                    EXTRAATTRIB_HEADER.required=:required,
                    EXTRAATTRIB_HEADER.visible=:visible,
                    EXTRAATTRIB_HEADER.locked=:locked,
                    EXTRAATTRIB_HEADER.multilnk=:multilnk,
                    EXTRAATTRIB_HEADER.lnk_species=:lnk_species,
                    EXTRAATTRIB_HEADER.lnk_eidosid=:lnk_eidosid,
                    EXTRAATTRIB_HEADER.lnk_hypid=:lnk_hypid,
                    EXTRAATTRIB_HEADER.lnk_needlist=:lnk_needlist

            where id=:id;
            --select id from EXTRAATTRIB_HEADER where EXTRAATTRIB_HEADER.id =:id   into :id_out ;
            id_out=:id;
        end
end^


ALTER PROCEDURE SET_HYPOTESIS (
    ID INTEGER,
    ID_EIDOS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:ID<1) then
        begin
            id_out=GEN_ID(GEN_ID_ALL,1);
            insert into HYPOTESIS (hypotesis.id,  HYPOTESIS.id_eidos ) values (:id_out, :id_eidos );
            --select max(HYPOTESIS.id) from HYPOTESIS where (HYPOTESIS.id_eidos =:id_eidos) into :id_out ;
        end
    else
        begin
            update HYPOTESIS set HYPOTESIS.id_eidos =:id_eidos where id=:id ;
            --select id from HYPOTESIS where HYPOTESIS.id =:id into :id_out ;
            id_out=:id;
        end
end^


ALTER PROCEDURE SET_LEVEL_INEIDOS
AS
declare variable id integer;
declare variable "LEV" integer;
declare variable id_parent integer;
begin
for
    select eidos.id,eidos.id_parent from eidos into :id, :id_parent
do
    begin
         if(:id_parent=0) then update eidos set eidos."LEVEL"=1 where eidos.id=:id;
         else
         begin
            lev=1;
            while (:id_parent>0) do
                begin
                    SELECT eidos.id_parent from eidos
                    where eidos.id=:id_parent into :id_parent;
                    lev=:lev+1;
                end
            update eidos set eidos."LEVEL"=:lev where eidos.id=:id;
        end
    end

end^


ALTER PROCEDURE SET_PRAGMA (
    ID INTEGER,
    ID_EIDOS INTEGER,
    ID_HYPOTESIS INTEGER)
RETURNS (
    ID_OUT INTEGER)
AS
begin
    if (:ID<1) then
        begin
            id_out=GEN_ID(GEN_ID_ALL,1);
            insert into PRAGMA (pragma.id, PRAGMA.id_eidos,PRAGMA.id_Hypotesis)
              values (:id_out, :id_eidos,:id_hypotesis);
            --select max(PRAGMA.id) from PRAGMA where (PRAGMA.id_eidos =:id_eidos and PRAGMA.id_hypotesis=:id_hypotesis) into :id_out ;
        end
    else
        begin
            update PRAGMA set PRAGMA.id_eidos=:id_eidos,PRAGMA.id_hypotesis=:id_hypotesis where id=:id ;
            --select id from PRAGMA where PRAGMA.id =:id into :id_out ;
            id_out=:id;
        end
end^


ALTER PROCEDURE SP_GET_FOREIGN_KEY
RETURNS (
    PK VARCHAR(31),
    TABLENAME VARCHAR(31),
    FIELDNAMEPK VARCHAR(31),
    FK VARCHAR(31),
    TABLENAMESOURCE VARCHAR(31),
    FIELDNAMEFK VARCHAR(31))
AS
BEGIN
  FOR
    SELECT RDB$INDICES.RDB$INDEX_NAME PK, RDB$INDICES.RDB$RELATION_NAME TableName, RDB$INDEX_SEGMENTS.RDB$FIELD_NAME FieldNamePK,
           RDB$INDICES1.RDB$INDEX_NAME FK, RDB$INDICES1.RDB$RELATION_NAME TableNameSource, RDB$INDEX_SEGMENTS1.RDB$FIELD_NAME FieldNameFK
    FROM RDB$INDEX_SEGMENTS RDB$INDEX_SEGMENTS1
       INNER JOIN RDB$INDICES RDB$INDICES1 ON (RDB$INDEX_SEGMENTS1.RDB$INDEX_NAME = RDB$INDICES1.RDB$INDEX_NAME)
       INNER JOIN RDB$INDICES ON (RDB$INDICES1.RDB$FOREIGN_KEY = RDB$INDICES.RDB$INDEX_NAME)
       INNER JOIN RDB$INDEX_SEGMENTS ON (RDB$INDICES.RDB$INDEX_NAME = RDB$INDEX_SEGMENTS.RDB$INDEX_NAME)
    INTO :PK,
         :TABLENAME,
         :FIELDNAMEPK,
         :FK,
         :TABLENAMESOURCE,
         :FIELDNAMEFK
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_RB_FIELDS (
    RB_TABLENAME VARCHAR(31))
RETURNS (
    RDB$RELATION_NAME VARCHAR(31),
    RDB$FIELD_NAME VARCHAR(31),
    RDB$DESCRIPTION BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    RDB$FIELD_TYPE SMALLINT,
    RDB$TYPE_NAME VARCHAR(31),
    RDB$FIELD_LENGTH SMALLINT,
    RDB$FIELD_POSITION SMALLINT,
    RDB$FIELD_SCALE SMALLINT,
    RDB$FIELD_SUB_TYPE SMALLINT,
    RDB$FIELD_PRECISION SMALLINT,
    RDB$SEGMENT_LENGTH SMALLINT,
    RDB$NULL_FLAG SMALLINT,
    RDB$CONSTRAINT_NAME VARCHAR(31),
    RDB$CONSTRAINT_TYPE VARCHAR(11))
AS
BEGIN
  FOR
    SELECT VW_FIELDS.RDB$RELATION_NAME, VW_FIELDS.RDB$FIELD_NAME, VW_FIELDS.RDB$DESCRIPTION, VW_FIELDS.RDB$FIELD_TYPE,
    VW_FIELDS.RDB$TYPE_NAME, VW_FIELDS.RDB$FIELD_LENGTH, VW_FIELDS.RDB$FIELD_POSITION,
    VW_FIELDS.RDB$FIELD_SCALE, VW_FIELDS.RDB$FIELD_SUB_TYPE, VW_FIELDS.RDB$FIELD_PRECISION, VW_FIELDS.RDB$SEGMENT_LENGTH,VW_FIELDS.RDB$NULL_FLAG,
    VW_CONSTRAINTS.RDB$CONSTRAINT_NAME, VW_CONSTRAINTS.RDB$CONSTRAINT_TYPE
    FROM VW_FIELDS
       LEFT OUTER JOIN VW_CONSTRAINTS ON (VW_FIELDS.RDB$RELATION_NAME = VW_CONSTRAINTS.RDB$RELATION_NAME) AND (VW_FIELDS.RDB$FIELD_NAME = VW_CONSTRAINTS.RDB$FIELD_NAME)
       --INNER JOIN RB_DESCRIBER ON (VW_FIELDS.RDB$RELATION_NAME = RB_DESCRIBER.RB_TABLENAME)
    where VW_FIELDS.RDB$RELATION_NAME=:RB_TABLENAME
    INTO :RDB$RELATION_NAME,
         :RDB$FIELD_NAME,
         :RDB$DESCRIPTION,
         :RDB$FIELD_TYPE,
         :RDB$TYPE_NAME,
         :RDB$FIELD_LENGTH,
         :RDB$FIELD_POSITION,
         :RDB$FIELD_SCALE,
         :RDB$FIELD_SUB_TYPE,
         :RDB$FIELD_PRECISION,
         :RDB$SEGMENT_LENGTH,
         :RDB$NULL_FLAG,
         :RDB$CONSTRAINT_NAME,
         :RDB$CONSTRAINT_TYPE
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_RIGHTS_FOR_OBJECT (
    ID_OBJ INTEGER)
RETURNS (
    GROUP_NAME VARCHAR(255),
    RIGHT_NAME VARCHAR(64))
AS
BEGIN
  FOR
    SELECT GROUPS.NAME GROUP_NAME, ACCESS_RIGHT.NAME RIGHT_NAME
    FROM ACL
       INNER JOIN GROUPS ON (ACL.GID = GROUPS.ID)
       INNER JOIN ACCESS_RIGHT ON (ACL.ACCESS_RIGHT = ACCESS_RIGHT.ID)
       where  ACL.ID_OBJECT=:id_obj
    INTO :GROUP_NAME,
         :RIGHT_NAME
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_TEMPORALY_VALUE (
    ID_HEADER INTEGER)
RETURNS (
    ID_LINK INTEGER,
    ID INTEGER)
AS
DECLARE VARIABLE DT TIMESTAMP;
BEGIN
  select var_dt.dt from var_dt
  where var_dt.user_name=user into :dt;
  for
    SELECT DISTINCT TEMPORALITY.ID_LINK
    FROM TEMPORALITY
    WHERE 
    (
      (TEMPORALITY.ID_HEADER = :ID_HEADER)
    )
    into :id_link
 do
  begin
   SELECT first 1 TEMPORALITY.ID
   FROM TEMPORALITY
   where ((TEMPORALITY.ID_HEADER = :ID_HEADER) and (temporality.id_link=:id_link) and (TEMPORALITY.date_time<=:dt) )
    order by TEMPORALITY.DATE_TIME desc
   INTO :ID;
    SUSPEND;
  end

END^


ALTER PROCEDURE SP_GET_TYPE
RETURNS (
    ID SMALLINT,
    FIELD_TYPE SMALLINT,
    FIELD_TYPE_NAME VARCHAR(31),
    TYPE_NAME VARCHAR(62),
    FIELD_LENGTH SMALLINT,
    FIELD_SCALE SMALLINT,
    FIELD_SUB_TYPE SMALLINT,
    FIELD_PRECISION SMALLINT,
    SEGMENT_LENGTH SMALLINT,
    CAPTION VARCHAR(62))
AS
BEGIN
  FOR
    SELECT FIELDS_TYPE.ID, FIELDS_TYPE.FIELD_TYPE, FIELDS_TYPE.FIELD_TYPE_NAME, FIELDS_TYPE.TYPE_NAME, FIELDS_TYPE.FIELD_LENGTH, FIELDS_TYPE.FIELD_SCALE, FIELDS_TYPE.FIELD_SUB_TYPE, FIELDS_TYPE.FIELD_PRECISION, FIELDS_TYPE.SEGMENT_LENGTH, FIELDS_TYPE.CAPTION
    FROM FIELDS_TYPE
    INTO :ID,
         :FIELD_TYPE,
         :FIELD_TYPE_NAME,
         :TYPE_NAME,
         :FIELD_LENGTH,
         :FIELD_SCALE,
         :FIELD_SUB_TYPE,
         :FIELD_PRECISION,
         :SEGMENT_LENGTH,
         :CAPTION
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_USER_OBJ (
    TYPE_OBJ SMALLINT)
RETURNS (
    ID INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  FOR
    SELECT ID_OBJ.ID, MAX( ACL.ACCESS_RIGHT ) MAX_OF_ACCESS_RIGHT
    FROM ACL
       INNER JOIN ID_OBJ ON (ACL.ID_OBJECT = ID_OBJ.ID)
       INNER JOIN MEMBERSHIP ON (ACL.GID = MEMBERSHIP.GID)
    WHERE 
       (
          (MEMBERSHIP.USER_NAME = user)
       and 
          (ID_OBJ.TYPE_OBJ = :type_obj)
       )
    GROUP BY ID_OBJ.ID
    INTO :ID,
         :MAX_OF_ACCESS_RIGHT
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_USER_OBJECTS
RETURNS (
    ID_OBJECT INTEGER,
    MAX_OF_ACCESS_RIGHT INTEGER)
AS
BEGIN
  FOR
    SELECT VW_USER_OBIECTS1.ID_OBJECT, VW_USER_OBIECTS1.MAX_OF_ACCESS_RIGHT
    FROM VW_USER_OBIECTS
       INNER JOIN EXTRAATRIB_RB ON (EXTRAATRIB_RB."VALUE" = VW_USER_OBIECTS.ID_OBJECT )
       INNER JOIN EXTRAATTRIB_HEADER ON (EXTRAATRIB_RB.ID_HEADER = EXTRAATTRIB_HEADER.ID)
       INNER JOIN VW_USER_OBIECTS VW_USER_OBIECTS1 ON (EXTRAATRIB_RB.ID_LINK = VW_USER_OBIECTS1.ID_OBJECT)
    WHERE 
       (
          (EXTRAATTRIB_HEADER.FIELDNAME = 'PrBelongTo')
       )
    INTO :ID_OBJECT,
         :MAX_OF_ACCESS_RIGHT
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_GET_USER_PRAGMA
RETURNS (
    MAX_OF_ACCESS_RIGHT INTEGER,
    ID INTEGER)
AS
DECLARE VARIABLE ID_HEADER INTEGER;
begin
  SELECT EXTRAATTRIB_HEADER.id
  from EXTRAATTRIB_HEADER
  WHERE 
       (
          (EXTRAATTRIB_HEADER.FIELDNAME = 'PrBelongTo')
       )
  into :id_header;
  for
   SELECT ACL.ID_OBJECT, max(ACL.ACCESS_RIGHT)
    FROM ACL
        INNER JOIN EXTRAATRIB_RB ON (ACL.ID_OBJECT = EXTRAATRIB_RB.id_link)
        INNER JOIN MEMBERSHIP ON (ACL.GID = MEMBERSHIP.GID)
    WHERE 
    (
      (MEMBERSHIP.USER_NAME = user) and (EXTRAATRIB_RB.id_header=:id_header)
    )
    GROUP BY ACL.ID_OBJECT
   into  :id,
         :MAX_OF_ACCESS_RIGHT
   DO
  BEGIN
    SUSPEND;
  END

end^


ALTER PROCEDURE SP_GET_VAR_DT
RETURNS (
    DT TIMESTAMP)
AS
BEGIN
  FOR
    SELECT VAR_DT.DT
    FROM VAR_DT
    WHERE 
       (
          (VAR_DT.USER_NAME = user)
       )
    INTO :DT
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_CURRENT_USER
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  FOR
    SELECT USERS.UID, USERS.NAME, USERS.ID_TYPE_ACCES_RIGHT, USERS.FULL_NAME, USERS.DESCRIPTIONS, USERS.IS_DELETED, USERS.IS_DISABLED
    FROM USERS
    where (USERS.NAME=user)
    INTO :UID,
         :NAME,
         :ID_TYPE_ACCES_RIGHT,
         :FULL_NAME,
         :DESCRIPTIONS,
         :IS_DELETED,
         :IS_DISABLED
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC (
    OBJ VARCHAR(512),
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN
    --check user

    if (:uid=-1) then
        select uid from users where name=user into  :uid;

  FOR
   SELECT ETC.ID, ETC.OBJECT, ETC.ID_USER, USERS.NAME
   FROM USERS
   RIGHT OUTER JOIN ETC ON (USERS.UID = ETC.ID_USER)
   where etc.id_user=:uid and etc.object=:obj
    INTO :ID,
         :OBJECT,
         :ID_USER,
         :user_name
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_ALL (
    UID INTEGER)
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
BEGIN

    if (:uid<>-1) then
        select uid from users where name=user into  :uid;

  FOR
   SELECT ETC.ID, ETC.OBJECT, ETC.ID_USER, USERS.NAME
   FROM USERS
   RIGHT OUTER JOIN ETC ON (USERS.UID = ETC.ID_USER)
   where etc.id_user=:uid
    INTO :ID,
         :OBJECT,
         :ID_USER,
         :user_name
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_ALL2USER (
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    OBJECT VARCHAR(250),
    ID_USER INTEGER,
    USER_NAME VARCHAR(64))
AS
declare variable uid integer;
BEGIN


        select uid from users where name=:uname into  :uid;

  FOR
   SELECT ETC.ID, ETC.OBJECT, ETC.ID_USER, USERS.NAME
   FROM USERS
   RIGHT OUTER JOIN ETC ON (USERS.UID = ETC.ID_USER)
   where etc.id_user=:uid
    INTO :ID,
         :OBJECT,
         :ID_USER,
         :user_name
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_PARAMETERS (
    OBJECT_ID INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  FOR
    select etc_parameters.id, etc_parameters.name, etc_parameters.param_type, etc_parameters.id_object, etc_parameters.date_value, etc_parameters.float_value, etc_parameters.int_value, etc_parameters.string_value, etc_parameters.blob_value
    from etc_parameters
    where etc_parameters.id_object=:object_id
    INTO :ID,
         :NAME,
         :PARAM_TYPE,
         :ID_OBJECT,
         :DATE_VALUE,
         :FLOAT_VALUE,
         :INT_VALUE,
         :STRING_VALUE,
         :BLOB_VALUE
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_ETC_PARAMETERS2USER (
    OBJECT VARCHAR(512),
    UNAME VARCHAR(64))
RETURNS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE SMALLINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  FOR
    select etc_parameters.id, etc_parameters.name, etc_parameters.param_type, etc_parameters.id_object, etc_parameters.date_value, etc_parameters.float_value, etc_parameters.int_value, etc_parameters.string_value, etc_parameters.blob_value
        from users
            inner join etc on (users.uid = etc.id_user)
            inner join etc_parameters on (etc.id = etc_parameters.id_object)
        where 
         (
          (etc.object = :object)
           and 
          (users.name = :uname)
         )
    INTO :ID,
         :NAME,
         :PARAM_TYPE,
         :ID_OBJECT,
         :DATE_VALUE,
         :FLOAT_VALUE,
         :INT_VALUE,
         :STRING_VALUE,
         :BLOB_VALUE
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_FLOATS (
    PARAM_LINKS INTEGER)
RETURNS (
    ID INTEGER,
    "VALUE" DOUBLE PRECISION,
    LINKS INTEGER)
AS
BEGIN
  EXIT;
END^


ALTER PROCEDURE SP_READ_RB_DESCRIBER
RETURNS (
    ID INTEGER,
    RB_NAME VARCHAR(255),
    RB_TABLENAME VARCHAR(64),
    IS_RB_IERARCHY SMALLINT)
AS
BEGIN
  FOR
    SELECT RB_DESCRIBER.ID, RB_DESCRIBER.RB_NAME, RB_DESCRIBER.RB_TABLENAME, RB_DESCRIBER.IS_RB_IERARCHY
    FROM RB_DESCRIBER
    INTO :ID,
         :RB_NAME,
         :RB_TABLENAME,
         :IS_RB_IERARCHY
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_READ_USER_INFO
RETURNS (
    UID INTEGER,
    NAME VARCHAR(64),
    ID_TYPE_ACCES_RIGHT INTEGER,
    FULL_NAME VARCHAR(255),
    DESCRIPTIONS VARCHAR(255),
    IS_DELETED SMALLINT,
    IS_DISABLED SMALLINT)
AS
BEGIN
  FOR
    SELECT USERS.UID, USERS.NAME, USERS.ID_TYPE_ACCES_RIGHT, USERS.FULL_NAME, USERS.DESCRIPTIONS, USERS.IS_DELETED, USERS.IS_DISABLED
    FROM USERS where USERS.NAME=user
    INTO :UID,
         :NAME,
         :ID_TYPE_ACCES_RIGHT,
         :FULL_NAME,
         :DESCRIPTIONS,
         :IS_DELETED,
         :IS_DISABLED
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE SP_SET_ETC (
    ID INTEGER,
    OBJECT VARCHAR(512),
    ID_USER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
begin
  if (:id_user=-1) then SELECT USERS.UID FROM USERS where (USERS.NAME=user) INTO :id_user;
  if (:id < 1) then
        begin
           if(not(exists(select * from etc where etc.object=:object and etc.id_user=:id_user)))
            then
             begin
                result=gen_id(gen_etc,1);
                insert into ETC (id, object, ID_USER) values (:result, :object,:id_user);
             end
           else result=-1;
        end
      else
        if (:object ='') then
           begin
            delete from etc where id=:id;
            result=0;
           end
        else
            begin
             if((exists(select * from etc where etc.id=:id)))
               then
                if(not(exists(select * from etc where etc.object=:object and etc.id_user=:id_user))) then
                 begin
                   update etc set object=:object, id_user=:id_user where id=:id;
                   result=:id;
                 end
             else result=-1;
            end
end^


ALTER PROCEDURE SP_SET_ETC2OBJ (
    UNAME VARCHAR(64),
    OLD_OBJECT VARCHAR(512),
    NEW_OBJECT VARCHAR(512))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE SP_SET_PARAMETERS (
    ID INTEGER,
    NAME VARCHAR(250),
    PARAM_TYPE SMALLINT,
    ID_OBJECT INTEGER,
    DATE_VALUE TIMESTAMP,
    FLOAT_VALUE DOUBLE PRECISION,
    INT_VALUE BIGINT,
    STRING_VALUE VARCHAR(255),
    BLOB_VALUE BLOB SUB_TYPE 0 SEGMENT SIZE 4096)
RETURNS (
    RESULT INTEGER)
AS
declare variable old_name varchar(255);
declare variable old_id integer;
declare variable old_id_object integer;
declare variable old_param_type smallint;
begin
    if (:id < 1) then
        begin
           result=gen_id(gen_etc,1);
           insert into etc_parameters(id, name,param_type,id_object,date_value,float_value,int_value,string_value,blob_value)
            values(:result,:name,:param_type,:id_object,:date_value,:float_value,:int_value,:string_value,:blob_value);
        end
    else
        if (:name ='') then
           begin
            delete from etc_parameters where id=:id;
            result=0;
           end
        else
           begin
             update etc_parameters set name=:name, param_type=:param_type, id_object=:id_object, date_value=:date_value,
              float_value=:float_value, int_value=:int_value,string_value=:string_value,blob_value=:blob_value
             where id=:id;
             result=:id;
            end
end^


ALTER PROCEDURE SP_SET_RENAME_PARAMETER (
    ID INTEGER,
    NEW_NAME VARCHAR(250))
AS
begin
update etc_parameters set etc_parameters.name=:new_name where id=:id;
end^


ALTER PROCEDURE SP_SET_RIGHT (
    GID INTEGER,
    OID INTEGER,
    RID INTEGER,
    MODE SMALLINT)
AS
DECLARE VARIABLE ID INTEGER;
begin
--для конкреного объекта
    select first 1 id from ACL
    where gid=:gid and id_object=:oid into :id;
    if (not :id is null) then
          --update rigth
          update acl set access_right=:rid where id=:id;
    else
          insert into acl(gid,access_right,id_object) values(:gid,:rid,:oid);

if(:mode=1) then --и для дочерних?
--рекурсивно для всех дочерних объектов
    begin
        FOR
            SELECT id from id_obj 
                where id_parent=:oid into :id
        do
        begin
            EXECUTE PROCEDURE SP_SET_RIGHT(:gid,:id,:rid,:mode);
        end
    end
end^


ALTER PROCEDURE SP_SET_VAR_DT (
    DT TIMESTAMP)
AS
begin
if (exists(select user_name from var_dt where user_name=user)) then
    update var_dt set dt=:dt where user_name=user;
else
    insert into var_dt(user_name,dt) values(user,:dt);
end^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE ACCESS_RIGHT
'Описание прав доступа';

DESCRIBE TABLE ACL
'Список прав доступа';

DESCRIBE TABLE EIDOS_ALTCAPTION
'Таблица хранит заголовки полей которые требуется заменить в оригинальной модели';

DESCRIBE TABLE EXTRAATTRIB_ALTCAPTION
'Таблица хранит заголовки полей которые требуется заменить в оригинальной модели';

DESCRIBE TABLE GROUPS
'Таблица групп пользователей';

DESCRIBE TABLE IRB_STRUCTURES
'Таблица - справочник структурных подразделений/организаций';

DESCRIBE TABLE IRB_UNITMESUREMENT
'Справочник единиц измерения. Пример:
    Единицы объема
        м3
        дм3
        литр
    Единицы массы
        кг
        т
        гр';

DESCRIBE TABLE MEMBERSHIP
'Таблица членства пользователей в группе';

DESCRIBE TABLE TEMPORALITY
'Таблица служит для создания темпоральных структур полей';

DESCRIBE TABLE USERS
' РўР°Р±Р»РёС†Р° РїРѕР»СЊР·РѕРІР°С‚РµР»РµР№';

DESCRIBE TABLE VAR_DT
'Таблица переменной пользователя - состояние на дату';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE GET_EA_LIST_INT
'   Процедура возвращает список дополнительных атрибутов целого типа для экстраатрибута,
чей идентификатор передан в параметре. Вместе со значением возвращается идентификатор ссылки на объект';

DESCRIBE PROCEDURE GET_EA_LIST_RB
'Процедура возвращает список дополнительных атрибутов справочного типа для экстраатрибута,
чей идентификатор передан в параметре. Вместе со значением возвращается идентификатор ссылки на объект';

DESCRIBE PROCEDURE GET_EA_LIST_SECUR
'Возвращает список объектов с правами доступа к ним';

DESCRIBE PROCEDURE GET_EA_LIST_STR
'Процедура возвращает список дополнительных атрибутов строкового типа для экстраатрибута,
чей идентификатор передан в параметре. Вместе со значением возвращается идентификатор ссылки на объект';

DESCRIBE PROCEDURE GET_EA_NEWFIELDNAME
'Процедура создает имя поля для вновь создаваемых экстраатрибутов, при этом генерируется имя основанное на генераторе
для уникальности и конкатенируется с FLD префиксом, кое значение и возвращается в виде параметра';

DESCRIBE PROCEDURE SET_EA_RB
'Процедура меняет значение справочного экстраатрибута.';

DESCRIBE PROCEDURE SET_EA_SIMPLE_INT
'Процедура заносит значение экстраатрибута типа целых чисел';

DESCRIBE PROCEDURE SET_PRAGMA
'Запишем объект';

DESCRIBE PROCEDURE SP_GET_RB_FIELDS
'Возвращаем метаданные по имени таблицы';

DESCRIBE PROCEDURE SP_GET_RIGHTS_FOR_OBJECT
'Процедура возвращает список групп с правом доступа к данному объекту по его id';

DESCRIBE PROCEDURE SP_GET_TYPE
'Процедура возвращает типы данных';

DESCRIBE PROCEDURE SP_SET_RIGHT
'Изменение режима доступа к объекту для группы';

DESCRIBE PROCEDURE SP_SET_VAR_DT
'Устанавливаем пользовательское время состояния системы';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TRIGGER ID_OBJ_BD0
'Удаляем значения при удалении в мастер таблице';

DESCRIBE TRIGGER ID_OBJ_BI0
'Проверяем наличие значения в мастер-таблицах';

DESCRIBE TRIGGER TRG_USERS_BI0
'Генерация уникального id - автоинкремент';



/* Fields descriptions */

DESCRIBE FIELD AO TABLE ACCESS_RIGHT
'Admin option';

DESCRIBE FIELD A TABLE ACCESS_RIGHT
'Append';

DESCRIBE FIELD W TABLE ACCESS_RIGHT
'Write';

DESCRIBE FIELD D TABLE ACCESS_RIGHT
'Delete - право на удаление объекта';

DESCRIBE FIELD R TABLE ACCESS_RIGHT
'Read';

DESCRIBE FIELD GID TABLE ACL
'Идентификатор группы пользователей';

DESCRIBE FIELD ACCESS_RIGHT TABLE ACL
'Право доступа';

DESCRIBE FIELD ID_OBJECT TABLE ACL
'На объект';

DESCRIBE FIELD NAME TABLE GROUPS
'Название группы';

DESCRIBE FIELD ID TABLE ID_OBJ
'Идентификатор объекта';

DESCRIBE FIELD TYPE_OBJ TABLE ID_OBJ
'Тип объекта: 0 - Eidos, 1 - Hypotesis, 2 - Pragma';

DESCRIBE FIELD ID_PARENT TABLE ID_OBJ
'Для отображения иерархии при присвоении прав';

DESCRIBE FIELD FIRSTNAME TABLE IRB_HUMANS
'Имя';

DESCRIBE FIELD MIDDLENAME TABLE IRB_HUMANS
'Отчество';

DESCRIBE FIELD LASTNAME TABLE IRB_HUMANS
'Фамилия';

DESCRIBE FIELD LNK_ORGANIZATION TABLE IRB_HUMANS
'Ссылка на организацию';

DESCRIBE FIELD JOB_NAME TABLE IRB_HUMANS
'Должность';

DESCRIBE FIELD NAME TABLE IRB_OPERATIONS
'Имя операции';

DESCRIBE FIELD ID_PARENT TABLE IRB_PLACESUSE
'Ссылка народителя';

DESCRIBE FIELD NAME TABLE IRB_PLACESUSE
'Название места установки';

DESCRIBE FIELD ID_PARENT TABLE IRB_RESOURCES
'Ссылка на родителя';

DESCRIBE FIELD NAME TABLE IRB_RESOURCES
'Наименование ресурса';

DESCRIBE FIELD LNK_UNITMESUR TABLE IRB_RESOURCES
'Ссылка на справочник единиц измерения';

DESCRIBE FIELD ID_PARENT TABLE IRB_STRUCTURES
'Ссылка на родителя';

DESCRIBE FIELD NAME TABLE IRB_STRUCTURES
'Наименование организации';

DESCRIBE FIELD INN TABLE IRB_STRUCTURES
'ИНН';

DESCRIBE FIELD LNK_HUMANS_CHIEF TABLE IRB_STRUCTURES
'Ссылка на справочник персон - начальника организации';

DESCRIBE FIELD ID_PARENT TABLE IRB_UNITMESUREMENT
'Ссылка на родителя';

DESCRIBE FIELD NAME TABLE IRB_UNITMESUREMENT
'Имя единицы измерения';

DESCRIBE FIELD GID TABLE MEMBERSHIP
'Идентификатор группы';

DESCRIBE FIELD USER_NAME TABLE MEMBERSHIP
'Пользователь';

DESCRIBE FIELD RB_NAME TABLE RB_DESCRIBER
' Имя справочника';

DESCRIBE FIELD RB_TABLENAME TABLE RB_DESCRIBER
'Имя таблицы справочника';

DESCRIBE FIELD IS_RB_IERARCHY TABLE RB_DESCRIBER
'Признак иерархического справочника';

DESCRIBE FIELD ID TABLE TEMPORALITY
' Является ли комбинация id,id_link уникальной?';

DESCRIBE FIELD ID_HEADER TABLE TEMPORALITY
'Идентификатор атрибута';

